ARM GAS  /tmp/cclyB5Uc.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"main.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.MX_GPIO_Init,"ax",%progbits
  18              		.align	2
  19              		.code	16
  20              		.thumb_func
  22              	MX_GPIO_Init:
  23              	.LFB47:
  24              		.file 1 "Src/main.c"
   1:Src/main.c    **** 
   2:Src/main.c    **** /**
   3:Src/main.c    ****   ******************************************************************************
   4:Src/main.c    ****   * @file           : main.c
   5:Src/main.c    ****   * @brief          : Main program body
   6:Src/main.c    ****   ******************************************************************************
   7:Src/main.c    ****   * This notice applies to any and all portions of this file
   8:Src/main.c    ****   * that are not between comment pairs USER CODE BEGIN and
   9:Src/main.c    ****   * USER CODE END. Other portions of this file, whether
  10:Src/main.c    ****   * inserted by the user or by software development tools
  11:Src/main.c    ****   * are owned by their respective copyright owners.
  12:Src/main.c    ****   *
  13:Src/main.c    ****   * Copyright (c) 2018 STMicroelectronics International N.V.
  14:Src/main.c    ****   * All rights reserved.
  15:Src/main.c    ****   *
  16:Src/main.c    ****   * Redistribution and use in source and binary forms, with or without
  17:Src/main.c    ****   * modification, are permitted, provided that the following conditions are met:
  18:Src/main.c    ****   *
  19:Src/main.c    ****   * 1. Redistribution of source code must retain the above copyright notice,
  20:Src/main.c    ****   *    this list of conditions and the following disclaimer.
  21:Src/main.c    ****   * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:Src/main.c    ****   *    this list of conditions and the following disclaimer in the documentation
  23:Src/main.c    ****   *    and/or other materials provided with the distribution.
  24:Src/main.c    ****   * 3. Neither the name of STMicroelectronics nor the names of other
  25:Src/main.c    ****   *    contributors to this software may be used to endorse or promote products
  26:Src/main.c    ****   *    derived from this software without specific written permission.
  27:Src/main.c    ****   * 4. This software, including modifications and/or derivative works of this
  28:Src/main.c    ****   *    software, must execute solely and exclusively on microcontroller or
  29:Src/main.c    ****   *    microprocessor devices manufactured by or for STMicroelectronics.
  30:Src/main.c    ****   * 5. Redistribution and use of this software other than as permitted under
  31:Src/main.c    ****   *    this license is void and will automatically terminate your rights under
  32:Src/main.c    ****   *    this license.
  33:Src/main.c    ****   *
  34:Src/main.c    ****   * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS"
ARM GAS  /tmp/cclyB5Uc.s 			page 2


  35:Src/main.c    ****   * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT
  36:Src/main.c    ****   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  37:Src/main.c    ****   * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
  38:Src/main.c    ****   * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT
  39:Src/main.c    ****   * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  40:Src/main.c    ****   * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  41:Src/main.c    ****   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  42:Src/main.c    ****   * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  43:Src/main.c    ****   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  44:Src/main.c    ****   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  45:Src/main.c    ****   * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  46:Src/main.c    ****   *
  47:Src/main.c    ****   ******************************************************************************
  48:Src/main.c    ****   */
  49:Src/main.c    **** /* Includes ------------------------------------------------------------------*/
  50:Src/main.c    **** #include "main.h"
  51:Src/main.c    **** #include "stm32f0xx_hal.h"
  52:Src/main.c    **** #include "usb_device.h"
  53:Src/main.c    **** 
  54:Src/main.c    **** /* USER CODE BEGIN Includes */
  55:Src/main.c    **** #include "device_conf.h"
  56:Src/main.c    **** #include "curemisc.h"
  57:Src/main.c    **** #include "curebuffer.h"
  58:Src/main.c    **** #include "usbd_midi_if.h"
  59:Src/main.c    **** #include "math.h"
  60:Src/main.c    **** 
  61:Src/main.c    **** /* USER CODE END Includes */
  62:Src/main.c    **** 
  63:Src/main.c    **** /* Private variables ---------------------------------------------------------*/
  64:Src/main.c    **** TIM_HandleTypeDef htim14;
  65:Src/main.c    **** TIM_HandleTypeDef htim15;
  66:Src/main.c    **** 
  67:Src/main.c    **** TIM_HandleTypeDef htim17;
  68:Src/main.c    **** 
  69:Src/main.c    **** TIM_HandleTypeDef htim2;
  70:Src/main.c    **** 
  71:Src/main.c    **** TIM_HandleTypeDef htim1;
  72:Src/main.c    **** 
  73:Src/main.c    **** DAC_HandleTypeDef hdac;
  74:Src/main.c    **** 
  75:Src/main.c    **** ADC_HandleTypeDef hadc;
  76:Src/main.c    **** DMA_HandleTypeDef hdma_adc;
  77:Src/main.c    **** 
  78:Src/main.c    **** uint16_t adcBuffer[3];
  79:Src/main.c    **** 
  80:Src/main.c    **** 
  81:Src/main.c    **** uint8_t uart_tx_dat;
  82:Src/main.c    **** /* USER CODE END PV */
  83:Src/main.c    **** 
  84:Src/main.c    **** /* Private function prototypes -----------------------------------------------*/
  85:Src/main.c    **** void SystemClock_Config(void);
  86:Src/main.c    **** static void MX_GPIO_Init(void);
  87:Src/main.c    **** 
  88:Src/main.c    **** static void MX_TIM14_Init(void);
  89:Src/main.c    **** static void MX_TIM15_Init(void);
  90:Src/main.c    **** static void MX_TIM17_Init(void);
  91:Src/main.c    **** static void USER_TIM2_Init(void);
ARM GAS  /tmp/cclyB5Uc.s 			page 3


  92:Src/main.c    **** static void USER_TIM1_Init(void);
  93:Src/main.c    **** 
  94:Src/main.c    **** static void MX_DAC_Init(void);
  95:Src/main.c    **** 
  96:Src/main.c    **** static void MX_DMA_Init(void);
  97:Src/main.c    **** static void MX_ADC_Init(void);
  98:Src/main.c    **** 
  99:Src/main.c    **** void htim17_update(void);
 100:Src/main.c    **** 
 101:Src/main.c    **** uint32_t Vout = 0;
 102:Src/main.c    **** uint16_t Iout = 0;
 103:Src/main.c    **** uint32_t Vset = 0;
 104:Src/main.c    **** uint32_t Vmax = 52000;
 105:Src/main.c    **** 
 106:Src/main.c    **** void htim17_update() {
 107:Src/main.c    ****   Iout = adcBuffer[0] * 1.33f;
 108:Src/main.c    ****   Vout = adcBuffer[1] * 16.6f;
 109:Src/main.c    ****   int32_t error = Vset - Vout;
 110:Src/main.c    **** 
 111:Src/main.c    ****   TIM1->CCR1 = CLAMP(error / 3, 0, 500);
 112:Src/main.c    **** 
 113:Src/main.c    ****   if (Vout > 55000) {
 114:Src/main.c    ****     TIM1->CCR1 = 0;
 115:Src/main.c    ****   }
 116:Src/main.c    **** }
 117:Src/main.c    **** 
 118:Src/main.c    **** /* USER CODE BEGIN PFP */
 119:Src/main.c    **** /* Private function prototypes -----------------------------------------------*/
 120:Src/main.c    **** void dfu_otter_bootloader(void)
 121:Src/main.c    **** {
 122:Src/main.c    ****   *((unsigned long *)0x20003FF0) = 0xDEADBEEF;
 123:Src/main.c    ****   NVIC_SystemReset();
 124:Src/main.c    **** }
 125:Src/main.c    **** /* USER CODE END PFP */
 126:Src/main.c    **** 
 127:Src/main.c    **** /* USER CODE BEGIN 0 */
 128:Src/main.c    **** 
 129:Src/main.c    **** uint32_t curPeriode0 = 0;
 130:Src/main.c    **** uint32_t curPeriode1 = 0;
 131:Src/main.c    **** 
 132:Src/main.c    **** void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
 133:Src/main.c    **** {
 134:Src/main.c    **** 	if(htim->Instance == TIM14)
 135:Src/main.c    **** 	{
 136:Src/main.c    **** 		//HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_2);
 137:Src/main.c    ****     if (TIM2->CNT == 0) {
 138:Src/main.c    ****       TIM2->ARR = (uint32_t)(curPeriode0 / CLAMP(((Iout/200)-10), 3, 16)); // Play first channel
 139:Src/main.c    ****     	TIM2->CR1 = TIM2->CR1 | 1;
 140:Src/main.c    ****     }
 141:Src/main.c    **** 	}
 142:Src/main.c    **** 	if(htim->Instance == TIM15)
 143:Src/main.c    **** 	{
 144:Src/main.c    **** 		//HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_2);
 145:Src/main.c    ****     if (TIM2->CNT == 0) {
 146:Src/main.c    ****     	TIM2->ARR = (uint32_t)(curPeriode1 / 8); // Play second channel with less power
 147:Src/main.c    ****     	TIM2->CR1 = TIM2->CR1 | 1;
 148:Src/main.c    ****     }
ARM GAS  /tmp/cclyB5Uc.s 			page 4


 149:Src/main.c    **** 	}
 150:Src/main.c    **** }
 151:Src/main.c    **** 
 152:Src/main.c    **** /**
 153:Src/main.c    ****   * @brief  The application entry point.
 154:Src/main.c    ****   *
 155:Src/main.c    ****   * @retval None
 156:Src/main.c    ****   */
 157:Src/main.c    **** 
 158:Src/main.c    **** 
 159:Src/main.c    **** uint8_t midiBuffer[4];
 160:Src/main.c    **** uint8_t midiState = 0;
 161:Src/main.c    **** 
 162:Src/main.c    **** uint16_t curTone0 = 0;
 163:Src/main.c    **** uint16_t curTone1 = 0;
 164:Src/main.c    **** uint16_t curChannel = 0;
 165:Src/main.c    **** uint16_t lastTone0 = 0;
 166:Src/main.c    **** uint16_t lastTone1 = 0;
 167:Src/main.c    **** uint32_t noteTimeout = 0;
 168:Src/main.c    **** 
 169:Src/main.c    **** uint16_t freqs[16] = {0};
 170:Src/main.c    **** 
 171:Src/main.c    **** 
 172:Src/main.c    **** int main(void)
 173:Src/main.c    **** {
 174:Src/main.c    ****   /* USER CODE BEGIN 1 */
 175:Src/main.c    **** 
 176:Src/main.c    ****   /* USER CODE END 1 */
 177:Src/main.c    **** 
 178:Src/main.c    ****   /* MCU Configuration----------------------------------------------------------*/
 179:Src/main.c    **** 
 180:Src/main.c    ****   /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
 181:Src/main.c    ****   HAL_Init();
 182:Src/main.c    **** 
 183:Src/main.c    ****   /* USER CODE BEGIN Init */
 184:Src/main.c    **** 
 185:Src/main.c    ****   /* USER CODE END Init */
 186:Src/main.c    **** 
 187:Src/main.c    ****   /* Configure the system clock */
 188:Src/main.c    ****   SystemClock_Config();
 189:Src/main.c    **** 
 190:Src/main.c    ****   /* USER CODE BEGIN SysInit */
 191:Src/main.c    **** 
 192:Src/main.c    ****   /* USER CODE END SysInit */
 193:Src/main.c    **** 
 194:Src/main.c    ****   /* Initialize all configured peripherals */
 195:Src/main.c    ****   MX_GPIO_Init();
 196:Src/main.c    ****   HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 197:Src/main.c    ****   HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, SET);
 198:Src/main.c    **** 
 199:Src/main.c    **** 	MX_DAC_Init();
 200:Src/main.c    **** 
 201:Src/main.c    **** 	HAL_DAC_Start(&hdac, DAC_CHANNEL_1);
 202:Src/main.c    **** 	HAL_DAC_SetValue(&hdac, DAC_CHANNEL_1, DAC_ALIGN_12B_R, 2048);
 203:Src/main.c    **** 
 204:Src/main.c    **** 	MX_TIM14_Init();
 205:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim14);
ARM GAS  /tmp/cclyB5Uc.s 			page 5


 206:Src/main.c    **** 	TIM14->CR1 &= ~(1UL);
 207:Src/main.c    **** 
 208:Src/main.c    **** 	MX_TIM15_Init();
 209:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim15);
 210:Src/main.c    **** 	TIM15->CR1 &= ~(1UL);
 211:Src/main.c    **** 
 212:Src/main.c    ****   MX_DMA_Init();
 213:Src/main.c    ****   MX_ADC_Init();
 214:Src/main.c    **** 
 215:Src/main.c    ****   HAL_ADC_Start_DMA(&hadc, (uint32_t*)adcBuffer, 3);
 216:Src/main.c    **** 
 217:Src/main.c    **** 
 218:Src/main.c    **** 	USER_TIM1_Init();
 219:Src/main.c    **** 
 220:Src/main.c    ****   //HAL_TIM_PWM_Start(&htim1);
 221:Src/main.c    ****   HAL_TIM_PWM_Start_IT(&htim1, TIM_CHANNEL_1);
 222:Src/main.c    **** 
 223:Src/main.c    ****   //__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, 1000);
 224:Src/main.c    **** 
 225:Src/main.c    ****   USER_TIM2_Init();
 226:Src/main.c    **** 
 227:Src/main.c    **** 	HAL_TIM_Base_Start(&htim2);
 228:Src/main.c    **** 	HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_2);
 229:Src/main.c    **** 
 230:Src/main.c    ****   /* USER CODE BEGIN 2 */
 231:Src/main.c    **** 
 232:Src/main.c    ****   //USB-MIDI Init
 233:Src/main.c    ****   MX_USB_MIDI_INIT();
 234:Src/main.c    **** 
 235:Src/main.c    ****   //HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 236:Src/main.c    **** 
 237:Src/main.c    **** 
 238:Src/main.c    ****   if(FUNC_ERROR == midiInit() ){
 239:Src/main.c    **** 	  while(1){
 240:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 241:Src/main.c    **** 		  HAL_Delay(500);
 242:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 243:Src/main.c    **** 		  HAL_Delay(500);
 244:Src/main.c    **** 	  }
 245:Src/main.c    ****   }
 246:Src/main.c    **** 
 247:Src/main.c    ****   //Wait usb configuration.
 248:Src/main.c    ****   while(1){
 249:Src/main.c    **** 	  if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 250:Src/main.c    **** 		  //HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 251:Src/main.c    **** 		  break;
 252:Src/main.c    **** 	  }else{
 253:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 254:Src/main.c    **** 	  }
 255:Src/main.c    ****   }
 256:Src/main.c    **** 
 257:Src/main.c    ****   MX_TIM17_Init();
 258:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim17);
 259:Src/main.c    **** 
 260:Src/main.c    ****   for (uint32_t i = 0; i < Vmax; i+=100) {
 261:Src/main.c    ****     Vset = i;
 262:Src/main.c    ****     HAL_Delay(3);
ARM GAS  /tmp/cclyB5Uc.s 			page 6


 263:Src/main.c    ****   }
 264:Src/main.c    **** 
 265:Src/main.c    ****   HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 266:Src/main.c    **** 
 267:Src/main.c    ****   Vset = Vmax;
 268:Src/main.c    **** 
 269:Src/main.c    ****   while (1)
 270:Src/main.c    ****   {
 271:Src/main.c    ****   //Wait USB configuration when USB connection error has occurred.
 272:Src/main.c    **** 	   while(1){
 273:Src/main.c    **** 				//HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 274:Src/main.c    **** 			if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 275:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 276:Src/main.c    **** 			  break;
 277:Src/main.c    **** 		  }else{
 278:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 279:Src/main.c    **** 			  HAL_Delay(200);
 280:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 281:Src/main.c    **** 			  HAL_Delay(200);
 282:Src/main.c    **** 		  }
 283:Src/main.c    **** 	  }
 284:Src/main.c    ****     if (HAL_GPIO_ReadPin(BUTTON_GPIO, BUTTON_PIN)) {
 285:Src/main.c    ****       dfu_otter_bootloader();
 286:Src/main.c    ****     }
 287:Src/main.c    **** 
 288:Src/main.c    **** 
 289:Src/main.c    **** 		curTone0 = 0;
 290:Src/main.c    **** 		curTone1 = 0;
 291:Src/main.c    **** 
 292:Src/main.c    **** 	  for( int i = 0; i < 16; i++ ) { // find max pitch from all channels
 293:Src/main.c    **** 	      if( freqs[i] > curTone0 ) {
 294:Src/main.c    **** 	          curTone1 = curTone0;
 295:Src/main.c    **** 	          curTone0 = freqs[i];
 296:Src/main.c    **** 	      }
 297:Src/main.c    **** 	      else if( freqs[i] > curTone1 ) {
 298:Src/main.c    **** 	          curTone1 = freqs[i];
 299:Src/main.c    **** 	      }
 300:Src/main.c    **** 	  }
 301:Src/main.c    **** 
 302:Src/main.c    **** 		if (curTone0 > 20 && curTone0 != lastTone0) { // play one tone using TIM14
 303:Src/main.c    **** 			curPeriode0 = (uint32_t)1000000 / (uint32_t)(curTone0);
 304:Src/main.c    **** 			TIM14->CNT = 0;
 305:Src/main.c    **** 			TIM14->ARR = curPeriode0;
 306:Src/main.c    **** 			TIM14->CR1 = TIM14->CR1 | 1;
 307:Src/main.c    **** 			lastTone0 = curTone0;
 308:Src/main.c    **** 			noteTimeout = HAL_GetTick();
 309:Src/main.c    **** 
 310:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, SET);
 311:Src/main.c    **** 		} else if (curTone0 < 20 && curTone0 != lastTone0) {
 312:Src/main.c    **** 			TIM14->CR1 &= ~(1UL);
 313:Src/main.c    ****       curPeriode0 = 0;
 314:Src/main.c    **** 
 315:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 316:Src/main.c    **** 		}
 317:Src/main.c    **** 
 318:Src/main.c    **** 		if (curTone1 > 20 && curTone1 != lastTone1) { // play other polyphonic tone ussing TIM15
 319:Src/main.c    **** 			curPeriode1 = (uint32_t)1000000 / (uint32_t)(curTone1);
ARM GAS  /tmp/cclyB5Uc.s 			page 7


 320:Src/main.c    **** 			TIM15->CNT = 0;
 321:Src/main.c    **** 			TIM15->ARR = curPeriode1;
 322:Src/main.c    **** 			TIM15->CR1 = TIM15->CR1 | 1;
 323:Src/main.c    **** 			lastTone1 = curTone1;
 324:Src/main.c    **** 			noteTimeout = HAL_GetTick();
 325:Src/main.c    **** 		} else if (curTone1 < 20 && curTone1 != lastTone1) {
 326:Src/main.c    **** 			TIM15->CR1 &= ~(1UL);
 327:Src/main.c    ****       curPeriode1 = 0;
 328:Src/main.c    **** 		}
 329:Src/main.c    **** 
 330:Src/main.c    **** 		if ((HAL_GetTick() - noteTimeout) > 1000) {
 331:Src/main.c    **** 			TIM14->CR1 &= ~(1UL);
 332:Src/main.c    **** 			TIM15->CR1 &= ~(1UL);
 333:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 334:Src/main.c    **** 				freqs[i] = 0;
 335:Src/main.c    **** 			}
 336:Src/main.c    **** 
 337:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 338:Src/main.c    **** 		}
 339:Src/main.c    **** 
 340:Src/main.c    **** 
 341:Src/main.c    **** 		//[USB-MIDI IN] to [MIDI JACK OUT]
 342:Src/main.c    **** 
 343:Src/main.c    **** 		if( FUNC_SUCCESS == midiGetFromUsbRx(0, &uart_tx_dat)){
 344:Src/main.c    **** 			if (uart_tx_dat >> 7 == 1) {
 345:Src/main.c    **** 				midiBuffer[0] = uart_tx_dat;
 346:Src/main.c    **** 				midiBuffer[1] = 0;
 347:Src/main.c    **** 				midiBuffer[2] = 0;
 348:Src/main.c    **** 				midiState = 1;
 349:Src/main.c    **** 			} else if (midiState == 1) {
 350:Src/main.c    **** 				midiBuffer[1] = uart_tx_dat;
 351:Src/main.c    **** 				midiState = 2;
 352:Src/main.c    **** 			} else if (midiState == 2) {
 353:Src/main.c    **** 				midiBuffer[2] = uart_tx_dat;
 354:Src/main.c    **** 				midiState = 3;
 355:Src/main.c    **** 
 356:Src/main.c    **** 				if ((midiBuffer[0] & 0xF0) == 0x90) { // Note on, 2 data bytes
 357:Src/main.c    **** 					char key = midiBuffer[1];
 358:Src/main.c    **** 					char vel = midiBuffer[2];
 359:Src/main.c    **** 
 360:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 361:Src/main.c    **** 					curChannel = midiBuffer[0] & 0xF;
 362:Src/main.c    **** 					freqs[curChannel] = freq;
 363:Src/main.c    **** 
 364:Src/main.c    **** 
 365:Src/main.c    **** 				} if ((midiBuffer[0] &0xF0) == 0x80) { // Note off, 2 data bytes
 366:Src/main.c    **** 					char key = midiBuffer[1];
 367:Src/main.c    **** 					char vel = midiBuffer[2];
 368:Src/main.c    **** 
 369:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 370:Src/main.c    **** 
 371:Src/main.c    **** 					//if (freqs[midiBuffer[0] & 0xF] == freq) {
 372:Src/main.c    **** 					freqs[midiBuffer[0] & 0xF] = 0;
 373:Src/main.c    **** 					//}
 374:Src/main.c    **** 				}
 375:Src/main.c    **** 			}
 376:Src/main.c    **** 		}
ARM GAS  /tmp/cclyB5Uc.s 			page 8


 377:Src/main.c    **** 
 378:Src/main.c    **** 	//[MIDI JACK IN] to [USB-MIDI OUT]
 379:Src/main.c    **** 	//midiProcess();
 380:Src/main.c    **** 
 381:Src/main.c    **** 
 382:Src/main.c    ****   }
 383:Src/main.c    ****   /* USER CODE END 3 */
 384:Src/main.c    **** 
 385:Src/main.c    **** }
 386:Src/main.c    **** 
 387:Src/main.c    **** /** System Clock Configuration
 388:Src/main.c    **** */
 389:Src/main.c    **** void SystemClock_Config(void)
 390:Src/main.c    **** {
 391:Src/main.c    **** 
 392:Src/main.c    ****   RCC_OscInitTypeDef RCC_OscInitStruct;
 393:Src/main.c    ****   RCC_ClkInitTypeDef RCC_ClkInitStruct;
 394:Src/main.c    ****   RCC_PeriphCLKInitTypeDef PeriphClkInit;
 395:Src/main.c    **** 
 396:Src/main.c    ****     /**Initializes the CPU, AHB and APB busses clocks
 397:Src/main.c    ****     */
 398:Src/main.c    ****   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI14|RCC_OSCILLATORTYPE_HSI48;
 399:Src/main.c    ****   RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 400:Src/main.c    ****   RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
 401:Src/main.c    ****   RCC_OscInitStruct.HSI14CalibrationValue = 16;
 402:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 403:Src/main.c    ****   if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 404:Src/main.c    ****   {
 405:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 406:Src/main.c    ****   }
 407:Src/main.c    **** 
 408:Src/main.c    ****     /**Initializes the CPU, AHB and APB busses clocks
 409:Src/main.c    ****     */
 410:Src/main.c    ****   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 411:Src/main.c    ****                               |RCC_CLOCKTYPE_PCLK1;
 412:Src/main.c    ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
 413:Src/main.c    ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 414:Src/main.c    ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 415:Src/main.c    **** 
 416:Src/main.c    ****   if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 417:Src/main.c    ****   {
 418:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 419:Src/main.c    ****   }
 420:Src/main.c    **** 
 421:Src/main.c    ****   PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 422:Src/main.c    ****   PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
 423:Src/main.c    **** 
 424:Src/main.c    ****   if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 425:Src/main.c    ****   {
 426:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 427:Src/main.c    ****   }
 428:Src/main.c    **** 
 429:Src/main.c    ****     /**Configure the Systick interrupt time
 430:Src/main.c    ****     */
 431:Src/main.c    ****   HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 432:Src/main.c    **** 
 433:Src/main.c    ****     /**Configure the Systick
ARM GAS  /tmp/cclyB5Uc.s 			page 9


 434:Src/main.c    ****     */
 435:Src/main.c    ****   HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 436:Src/main.c    **** 
 437:Src/main.c    ****   /* SysTick_IRQn interrupt configuration */
 438:Src/main.c    ****   HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 439:Src/main.c    **** }
 440:Src/main.c    **** 
 441:Src/main.c    **** /* ADC init function */
 442:Src/main.c    **** static void MX_ADC_Init(void)
 443:Src/main.c    **** {
 444:Src/main.c    ****   __HAL_RCC_ADC1_CLK_ENABLE();
 445:Src/main.c    ****   ADC_ChannelConfTypeDef sConfig;
 446:Src/main.c    **** 
 447:Src/main.c    ****     /**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of co
 448:Src/main.c    ****     */
 449:Src/main.c    ****   hadc.Instance = ADC1;
 450:Src/main.c    ****   hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 451:Src/main.c    ****   hadc.Init.Resolution = ADC_RESOLUTION_12B;
 452:Src/main.c    ****   hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 453:Src/main.c    ****   hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 454:Src/main.c    ****   hadc.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 455:Src/main.c    ****   hadc.Init.LowPowerAutoWait = DISABLE;
 456:Src/main.c    ****   hadc.Init.LowPowerAutoPowerOff = DISABLE;
 457:Src/main.c    ****   hadc.Init.ContinuousConvMode = DISABLE;
 458:Src/main.c    ****   hadc.Init.DiscontinuousConvMode = DISABLE;
 459:Src/main.c    ****   hadc.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T1_TRGO;
 460:Src/main.c    ****   hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 461:Src/main.c    ****   hadc.Init.DMAContinuousRequests = ENABLE;
 462:Src/main.c    ****   hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 463:Src/main.c    ****   if (HAL_ADC_Init(&hadc) != HAL_OK)
 464:Src/main.c    ****   {
 465:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 466:Src/main.c    ****   }
 467:Src/main.c    **** 
 468:Src/main.c    ****     /**Configure for the selected ADC regular channel to be converted.
 469:Src/main.c    ****     */
 470:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_0;
 471:Src/main.c    ****   sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 472:Src/main.c    ****   sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES_5;
 473:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 474:Src/main.c    ****   {
 475:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 476:Src/main.c    ****   }
 477:Src/main.c    **** 
 478:Src/main.c    ****     /**Configure for the selected ADC regular channel to be converted.
 479:Src/main.c    ****     */
 480:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_1;
 481:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 482:Src/main.c    ****   {
 483:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 484:Src/main.c    ****   }
 485:Src/main.c    **** 
 486:Src/main.c    ****     /**Configure for the selected ADC regular channel to be converted.
 487:Src/main.c    ****     */
 488:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_2;
 489:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 490:Src/main.c    ****   {
ARM GAS  /tmp/cclyB5Uc.s 			page 10


 491:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 492:Src/main.c    ****   }
 493:Src/main.c    **** 
 494:Src/main.c    **** 
 495:Src/main.c    **** }
 496:Src/main.c    **** 
 497:Src/main.c    **** /**
 498:Src/main.c    ****   * Enable DMA controller clock
 499:Src/main.c    ****   */
 500:Src/main.c    **** static void MX_DMA_Init(void)
 501:Src/main.c    **** {
 502:Src/main.c    ****   /* DMA controller clock enable */
 503:Src/main.c    ****   __HAL_RCC_DMA1_CLK_ENABLE();
 504:Src/main.c    **** 
 505:Src/main.c    ****   /* DMA interrupt init */
 506:Src/main.c    ****   /* DMA1_Channel1_IRQn interrupt configuration */
 507:Src/main.c    ****   HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 508:Src/main.c    ****   HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 509:Src/main.c    **** 
 510:Src/main.c    **** }
 511:Src/main.c    **** 
 512:Src/main.c    **** 
 513:Src/main.c    **** /* TIM14 init function */
 514:Src/main.c    **** static void MX_TIM14_Init(void)
 515:Src/main.c    **** {
 516:Src/main.c    ****   htim14.Instance = TIM14;
 517:Src/main.c    ****   htim14.Init.Prescaler = 11;
 518:Src/main.c    ****   htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 519:Src/main.c    ****   htim14.Init.Period = 1000;
 520:Src/main.c    ****   htim14.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 521:Src/main.c    ****   htim14.Init.RepetitionCounter = 0;
 522:Src/main.c    ****   htim14.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 523:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim14) != HAL_OK)
 524:Src/main.c    ****   {
 525:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 526:Src/main.c    ****   }
 527:Src/main.c    **** }
 528:Src/main.c    **** 
 529:Src/main.c    **** /* TIM15 init function */
 530:Src/main.c    **** static void MX_TIM15_Init(void)
 531:Src/main.c    **** {
 532:Src/main.c    ****   htim15.Instance = TIM15;
 533:Src/main.c    ****   htim15.Init.Prescaler = 11;
 534:Src/main.c    ****   htim15.Init.CounterMode = TIM_COUNTERMODE_UP;
 535:Src/main.c    ****   htim15.Init.Period = 1000;
 536:Src/main.c    ****   htim15.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 537:Src/main.c    ****   htim15.Init.RepetitionCounter = 0;
 538:Src/main.c    ****   htim15.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 539:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim15) != HAL_OK)
 540:Src/main.c    ****   {
 541:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 542:Src/main.c    ****   }
 543:Src/main.c    **** }
 544:Src/main.c    **** 
 545:Src/main.c    **** /* TIM17 init function */
 546:Src/main.c    **** static void MX_TIM17_Init(void)
 547:Src/main.c    **** {
ARM GAS  /tmp/cclyB5Uc.s 			page 11


 548:Src/main.c    ****   htim17.Instance = TIM17;
 549:Src/main.c    ****   htim17.Init.Prescaler = 11;
 550:Src/main.c    ****   htim17.Init.CounterMode = TIM_COUNTERMODE_UP;
 551:Src/main.c    ****   htim17.Init.Period = 1000;
 552:Src/main.c    ****   htim17.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 553:Src/main.c    ****   htim17.Init.RepetitionCounter = 0;
 554:Src/main.c    ****   htim17.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 555:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim17) != HAL_OK)
 556:Src/main.c    ****   {
 557:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 558:Src/main.c    ****   }
 559:Src/main.c    **** }
 560:Src/main.c    **** 
 561:Src/main.c    **** static void USER_TIM2_Init(void) {
 562:Src/main.c    **** 	__HAL_RCC_TIM2_CLK_ENABLE();
 563:Src/main.c    **** 
 564:Src/main.c    **** 	TIM_ClockConfigTypeDef sClockSourceConfig;
 565:Src/main.c    **** 	TIM_MasterConfigTypeDef sMasterConfig;
 566:Src/main.c    **** 	TIM_OC_InitTypeDef sConfigOC;
 567:Src/main.c    **** 
 568:Src/main.c    **** 	htim2.Instance = TIM2;
 569:Src/main.c    **** 	htim2.Init.Prescaler = 0;
 570:Src/main.c    **** 	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 571:Src/main.c    **** 	htim2.Init.Period = 3200;
 572:Src/main.c    **** 	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 573:Src/main.c    **** 	HAL_TIM_Base_Init(&htim2);
 574:Src/main.c    **** 
 575:Src/main.c    **** 	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 576:Src/main.c    **** 	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 577:Src/main.c    **** 	HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);
 578:Src/main.c    **** 
 579:Src/main.c    **** 	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 580:Src/main.c    **** 	sConfigOC.Pulse = 1;
 581:Src/main.c    **** 	sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;
 582:Src/main.c    **** 	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 583:Src/main.c    **** 	HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2);
 584:Src/main.c    **** 
 585:Src/main.c    **** 	HAL_TIM_OnePulse_Init(&htim2, TIM_OPMODE_SINGLE);
 586:Src/main.c    **** 	HAL_TIM_MspPostInit(&htim2);
 587:Src/main.c    **** }
 588:Src/main.c    **** 
 589:Src/main.c    **** static void USER_TIM1_Init(void)
 590:Src/main.c    **** {
 591:Src/main.c    ****   __HAL_RCC_TIM1_CLK_ENABLE();
 592:Src/main.c    **** 
 593:Src/main.c    ****   TIM_MasterConfigTypeDef sMasterConfig;
 594:Src/main.c    ****   TIM_OC_InitTypeDef sConfigOC;
 595:Src/main.c    ****   TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig;
 596:Src/main.c    **** 
 597:Src/main.c    ****   htim1.Instance = TIM1;
 598:Src/main.c    ****   htim1.Init.Prescaler = 0;
 599:Src/main.c    ****   htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 600:Src/main.c    ****   htim1.Init.Period = 1024;
 601:Src/main.c    ****   htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;
 602:Src/main.c    ****   htim1.Init.RepetitionCounter = 0;
 603:Src/main.c    ****   htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 604:Src/main.c    ****   if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
ARM GAS  /tmp/cclyB5Uc.s 			page 12


 605:Src/main.c    ****   {
 606:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 607:Src/main.c    ****   }
 608:Src/main.c    **** 
 609:Src/main.c    ****   sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 610:Src/main.c    ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 611:Src/main.c    ****   if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 612:Src/main.c    ****   {
 613:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 614:Src/main.c    ****   }
 615:Src/main.c    **** 
 616:Src/main.c    ****   sConfigOC.OCMode = TIM_OCMODE_PWM1;
 617:Src/main.c    ****   sConfigOC.Pulse = 0;
 618:Src/main.c    ****   sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 619:Src/main.c    ****   sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 620:Src/main.c    ****   sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 621:Src/main.c    ****   sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 622:Src/main.c    ****   sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 623:Src/main.c    ****   if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 624:Src/main.c    ****   {
 625:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 626:Src/main.c    ****   }
 627:Src/main.c    **** 
 628:Src/main.c    ****   sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 629:Src/main.c    ****   sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 630:Src/main.c    ****   sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 631:Src/main.c    ****   sBreakDeadTimeConfig.DeadTime = 0;
 632:Src/main.c    ****   sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 633:Src/main.c    ****   sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 634:Src/main.c    ****   sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 635:Src/main.c    ****   if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 636:Src/main.c    ****   {
 637:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 638:Src/main.c    ****   }
 639:Src/main.c    **** 
 640:Src/main.c    ****   HAL_TIM_MspPostInit(&htim1);
 641:Src/main.c    **** }
 642:Src/main.c    **** 
 643:Src/main.c    **** 
 644:Src/main.c    **** /* DAC init function */
 645:Src/main.c    **** static void MX_DAC_Init(void)
 646:Src/main.c    **** {
 647:Src/main.c    **** 
 648:Src/main.c    ****   DAC_ChannelConfTypeDef sConfig;
 649:Src/main.c    **** 
 650:Src/main.c    ****     /**DAC Initialization
 651:Src/main.c    ****     */
 652:Src/main.c    ****   hdac.Instance = DAC;
 653:Src/main.c    ****   if (HAL_DAC_Init(&hdac) != HAL_OK)
 654:Src/main.c    ****   {
 655:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 656:Src/main.c    ****   }
 657:Src/main.c    **** 
 658:Src/main.c    ****     /**DAC channel OUT1 config
 659:Src/main.c    ****     */
 660:Src/main.c    ****   sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
 661:Src/main.c    ****   sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
ARM GAS  /tmp/cclyB5Uc.s 			page 13


 662:Src/main.c    ****   if (HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1) != HAL_OK)
 663:Src/main.c    ****   {
 664:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 665:Src/main.c    ****   }
 666:Src/main.c    **** 
 667:Src/main.c    **** }
 668:Src/main.c    **** 
 669:Src/main.c    **** 
 670:Src/main.c    **** 
 671:Src/main.c    **** /**
 672:Src/main.c    ****   * Enable DMA controller clock
 673:Src/main.c    ****   */
 674:Src/main.c    **** 
 675:Src/main.c    **** 
 676:Src/main.c    **** /** Configure pins as
 677:Src/main.c    ****         * Analog
 678:Src/main.c    ****         * Input
 679:Src/main.c    ****         * Output
 680:Src/main.c    ****         * EVENT_OUT
 681:Src/main.c    ****         * EXTI
 682:Src/main.c    **** */
 683:Src/main.c    **** static void MX_GPIO_Init(void)
 684:Src/main.c    **** {
  25              		.loc 1 684 0
  26              		.cfi_startproc
  27 0000 30B5     		push	{r4, r5, lr}
  28              	.LCFI0:
  29              		.cfi_def_cfa_offset 12
  30              		.cfi_offset 4, -12
  31              		.cfi_offset 5, -8
  32              		.cfi_offset 14, -4
  33 0002 89B0     		sub	sp, sp, #36
  34              	.LCFI1:
  35              		.cfi_def_cfa_offset 48
  36              	.LBB8:
 685:Src/main.c    **** 
 686:Src/main.c    ****   GPIO_InitTypeDef GPIO_InitStruct;
 687:Src/main.c    **** 
 688:Src/main.c    ****   /* GPIO Ports Clock Enable */
 689:Src/main.c    ****   __HAL_RCC_GPIOF_CLK_ENABLE();
  37              		.loc 1 689 0
  38 0004 184B     		ldr	r3, .L2
  39 0006 5969     		ldr	r1, [r3, #20]
  40 0008 8022     		mov	r2, #128
  41 000a D203     		lsl	r2, r2, #15
  42 000c 1143     		orr	r1, r2
  43 000e 5961     		str	r1, [r3, #20]
  44 0010 5969     		ldr	r1, [r3, #20]
  45 0012 0A40     		and	r2, r1
  46 0014 0092     		str	r2, [sp]
  47 0016 009A     		ldr	r2, [sp]
  48              	.LBE8:
  49              	.LBB9:
 690:Src/main.c    ****   __HAL_RCC_GPIOA_CLK_ENABLE();
  50              		.loc 1 690 0
  51 0018 5969     		ldr	r1, [r3, #20]
  52 001a 8022     		mov	r2, #128
ARM GAS  /tmp/cclyB5Uc.s 			page 14


  53 001c 9202     		lsl	r2, r2, #10
  54 001e 1143     		orr	r1, r2
  55 0020 5961     		str	r1, [r3, #20]
  56 0022 5969     		ldr	r1, [r3, #20]
  57 0024 0A40     		and	r2, r1
  58 0026 0192     		str	r2, [sp, #4]
  59 0028 019A     		ldr	r2, [sp, #4]
  60              	.LBE9:
  61              	.LBB10:
 691:Src/main.c    ****   __HAL_RCC_GPIOB_CLK_ENABLE();
  62              		.loc 1 691 0
  63 002a 5969     		ldr	r1, [r3, #20]
  64 002c 8022     		mov	r2, #128
  65 002e D202     		lsl	r2, r2, #11
  66 0030 1143     		orr	r1, r2
  67 0032 5961     		str	r1, [r3, #20]
  68 0034 5B69     		ldr	r3, [r3, #20]
  69 0036 1A40     		and	r2, r3
  70 0038 0292     		str	r2, [sp, #8]
  71 003a 029B     		ldr	r3, [sp, #8]
  72              	.LBE10:
 692:Src/main.c    **** 
 693:Src/main.c    ****   /*Configure GPIO pin Output Level */
 694:Src/main.c    ****   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10|GPIO_PIN_15, GPIO_PIN_RESET);
  73              		.loc 1 694 0
  74 003c 9024     		mov	r4, #144
  75 003e E405     		lsl	r4, r4, #23
  76 0040 8425     		mov	r5, #132
  77 0042 2D02     		lsl	r5, r5, #8
  78 0044 201C     		mov	r0, r4
  79 0046 291C     		mov	r1, r5
  80 0048 0022     		mov	r2, #0
  81 004a FFF7FEFF 		bl	HAL_GPIO_WritePin
  82              	.LVL0:
 695:Src/main.c    **** 
 696:Src/main.c    ****   /*Configure GPIO pins : PA4 PA5 PA6 PA7 */
 697:Src/main.c    ****   GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_15;
  83              		.loc 1 697 0
  84 004e 0395     		str	r5, [sp, #12]
 698:Src/main.c    ****   GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  85              		.loc 1 698 0
  86 0050 0123     		mov	r3, #1
  87 0052 0493     		str	r3, [sp, #16]
 699:Src/main.c    ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
  88              		.loc 1 699 0
  89 0054 0023     		mov	r3, #0
  90 0056 0593     		str	r3, [sp, #20]
 700:Src/main.c    ****   GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  91              		.loc 1 700 0
  92 0058 0693     		str	r3, [sp, #24]
 701:Src/main.c    ****   HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  93              		.loc 1 701 0
  94 005a 201C     		mov	r0, r4
  95 005c 03A9     		add	r1, sp, #12
  96 005e FFF7FEFF 		bl	HAL_GPIO_Init
  97              	.LVL1:
 702:Src/main.c    **** }
ARM GAS  /tmp/cclyB5Uc.s 			page 15


  98              		.loc 1 702 0
  99 0062 09B0     		add	sp, sp, #36
 100              		@ sp needed
 101 0064 30BD     		pop	{r4, r5, pc}
 102              	.L3:
 103 0066 C046     		.align	2
 104              	.L2:
 105 0068 00100240 		.word	1073876992
 106              		.cfi_endproc
 107              	.LFE47:
 109              		.section	.text.MX_DMA_Init,"ax",%progbits
 110              		.align	2
 111              		.code	16
 112              		.thumb_func
 114              	MX_DMA_Init:
 115              	.LFB40:
 501:Src/main.c    **** {
 116              		.loc 1 501 0
 117              		.cfi_startproc
 118 0000 00B5     		push	{lr}
 119              	.LCFI2:
 120              		.cfi_def_cfa_offset 4
 121              		.cfi_offset 14, -4
 122 0002 83B0     		sub	sp, sp, #12
 123              	.LCFI3:
 124              		.cfi_def_cfa_offset 16
 125              	.LBB11:
 503:Src/main.c    ****   __HAL_RCC_DMA1_CLK_ENABLE();
 126              		.loc 1 503 0
 127 0004 094B     		ldr	r3, .L5
 128 0006 5969     		ldr	r1, [r3, #20]
 129 0008 0122     		mov	r2, #1
 130 000a 1143     		orr	r1, r2
 131 000c 5961     		str	r1, [r3, #20]
 132 000e 5B69     		ldr	r3, [r3, #20]
 133 0010 1A40     		and	r2, r3
 134 0012 0192     		str	r2, [sp, #4]
 135 0014 019B     		ldr	r3, [sp, #4]
 136              	.LBE11:
 507:Src/main.c    ****   HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 137              		.loc 1 507 0
 138 0016 0920     		mov	r0, #9
 139 0018 0021     		mov	r1, #0
 140 001a 0022     		mov	r2, #0
 141 001c FFF7FEFF 		bl	HAL_NVIC_SetPriority
 142              	.LVL2:
 508:Src/main.c    ****   HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 143              		.loc 1 508 0
 144 0020 0920     		mov	r0, #9
 145 0022 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 146              	.LVL3:
 510:Src/main.c    **** }
 147              		.loc 1 510 0
 148 0026 03B0     		add	sp, sp, #12
 149              		@ sp needed
 150 0028 00BD     		pop	{pc}
 151              	.L6:
ARM GAS  /tmp/cclyB5Uc.s 			page 16


 152 002a C046     		.align	2
 153              	.L5:
 154 002c 00100240 		.word	1073876992
 155              		.cfi_endproc
 156              	.LFE40:
 158              		.section	.text.USER_TIM2_Init,"ax",%progbits
 159              		.align	2
 160              		.code	16
 161              		.thumb_func
 163              	USER_TIM2_Init:
 164              	.LFB44:
 561:Src/main.c    **** static void USER_TIM2_Init(void) {
 165              		.loc 1 561 0
 166              		.cfi_startproc
 167 0000 70B5     		push	{r4, r5, r6, lr}
 168              	.LCFI4:
 169              		.cfi_def_cfa_offset 16
 170              		.cfi_offset 4, -16
 171              		.cfi_offset 5, -12
 172              		.cfi_offset 6, -8
 173              		.cfi_offset 14, -4
 174 0002 8AB0     		sub	sp, sp, #40
 175              	.LCFI5:
 176              		.cfi_def_cfa_offset 56
 177              	.LBB12:
 562:Src/main.c    **** 	__HAL_RCC_TIM2_CLK_ENABLE();
 178              		.loc 1 562 0
 179 0004 194B     		ldr	r3, .L8
 180 0006 DA69     		ldr	r2, [r3, #28]
 181 0008 0126     		mov	r6, #1
 182 000a 3243     		orr	r2, r6
 183 000c DA61     		str	r2, [r3, #28]
 184 000e DB69     		ldr	r3, [r3, #28]
 185 0010 3340     		and	r3, r6
 186 0012 0093     		str	r3, [sp]
 187 0014 009B     		ldr	r3, [sp]
 188              	.LBE12:
 568:Src/main.c    **** 	htim2.Instance = TIM2;
 189              		.loc 1 568 0
 190 0016 164C     		ldr	r4, .L8+4
 191 0018 8023     		mov	r3, #128
 192 001a DB05     		lsl	r3, r3, #23
 193 001c 2360     		str	r3, [r4]
 569:Src/main.c    **** 	htim2.Init.Prescaler = 0;
 194              		.loc 1 569 0
 195 001e 0025     		mov	r5, #0
 196 0020 6560     		str	r5, [r4, #4]
 570:Src/main.c    **** 	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 197              		.loc 1 570 0
 198 0022 A560     		str	r5, [r4, #8]
 571:Src/main.c    **** 	htim2.Init.Period = 3200;
 199              		.loc 1 571 0
 200 0024 C823     		mov	r3, #200
 201 0026 1B01     		lsl	r3, r3, #4
 202 0028 E360     		str	r3, [r4, #12]
 572:Src/main.c    **** 	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 203              		.loc 1 572 0
ARM GAS  /tmp/cclyB5Uc.s 			page 17


 204 002a 8023     		mov	r3, #128
 205 002c 9B00     		lsl	r3, r3, #2
 206 002e 2361     		str	r3, [r4, #16]
 573:Src/main.c    **** 	HAL_TIM_Base_Init(&htim2);
 207              		.loc 1 573 0
 208 0030 201C     		mov	r0, r4
 209 0032 FFF7FEFF 		bl	HAL_TIM_Base_Init
 210              	.LVL4:
 575:Src/main.c    **** 	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 211              		.loc 1 575 0
 212 0036 0895     		str	r5, [sp, #32]
 576:Src/main.c    **** 	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 213              		.loc 1 576 0
 214 0038 0995     		str	r5, [sp, #36]
 577:Src/main.c    **** 	HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);
 215              		.loc 1 577 0
 216 003a 201C     		mov	r0, r4
 217 003c 08A9     		add	r1, sp, #32
 218 003e FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 219              	.LVL5:
 579:Src/main.c    **** 	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 220              		.loc 1 579 0
 221 0042 6023     		mov	r3, #96
 222 0044 0193     		str	r3, [sp, #4]
 580:Src/main.c    **** 	sConfigOC.Pulse = 1;
 223              		.loc 1 580 0
 224 0046 0296     		str	r6, [sp, #8]
 581:Src/main.c    **** 	sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;
 225              		.loc 1 581 0
 226 0048 0223     		mov	r3, #2
 227 004a 0393     		str	r3, [sp, #12]
 582:Src/main.c    **** 	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 228              		.loc 1 582 0
 229 004c 0595     		str	r5, [sp, #20]
 583:Src/main.c    **** 	HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2);
 230              		.loc 1 583 0
 231 004e 201C     		mov	r0, r4
 232 0050 01A9     		add	r1, sp, #4
 233 0052 0422     		mov	r2, #4
 234 0054 FFF7FEFF 		bl	HAL_TIM_PWM_ConfigChannel
 235              	.LVL6:
 585:Src/main.c    **** 	HAL_TIM_OnePulse_Init(&htim2, TIM_OPMODE_SINGLE);
 236              		.loc 1 585 0
 237 0058 201C     		mov	r0, r4
 238 005a 0821     		mov	r1, #8
 239 005c FFF7FEFF 		bl	HAL_TIM_OnePulse_Init
 240              	.LVL7:
 586:Src/main.c    **** 	HAL_TIM_MspPostInit(&htim2);
 241              		.loc 1 586 0
 242 0060 201C     		mov	r0, r4
 243 0062 FFF7FEFF 		bl	HAL_TIM_MspPostInit
 244              	.LVL8:
 587:Src/main.c    **** }
 245              		.loc 1 587 0
 246 0066 0AB0     		add	sp, sp, #40
 247              		@ sp needed
 248 0068 70BD     		pop	{r4, r5, r6, pc}
ARM GAS  /tmp/cclyB5Uc.s 			page 18


 249              	.L9:
 250 006a C046     		.align	2
 251              	.L8:
 252 006c 00100240 		.word	1073876992
 253 0070 00000000 		.word	htim2
 254              		.cfi_endproc
 255              	.LFE44:
 257              		.global	__aeabi_i2f
 258              		.global	__aeabi_fmul
 259              		.global	__aeabi_f2uiz
 260              		.global	__aeabi_idiv
 261              		.section	.text.htim17_update,"ax",%progbits
 262              		.align	2
 263              		.global	htim17_update
 264              		.code	16
 265              		.thumb_func
 267              	htim17_update:
 268              	.LFB34:
 106:Src/main.c    **** void htim17_update() {
 269              		.loc 1 106 0
 270              		.cfi_startproc
 271 0000 10B5     		push	{r4, lr}
 272              	.LCFI6:
 273              		.cfi_def_cfa_offset 8
 274              		.cfi_offset 4, -8
 275              		.cfi_offset 14, -4
 107:Src/main.c    ****   Iout = adcBuffer[0] * 1.33f;
 276              		.loc 1 107 0
 277 0002 174C     		ldr	r4, .L16
 278 0004 2088     		ldrh	r0, [r4]
 279 0006 FFF7FEFF 		bl	__aeabi_i2f
 280              	.LVL9:
 281 000a 1649     		ldr	r1, .L16+4
 282 000c FFF7FEFF 		bl	__aeabi_fmul
 283              	.LVL10:
 284 0010 FFF7FEFF 		bl	__aeabi_f2uiz
 285              	.LVL11:
 286 0014 144B     		ldr	r3, .L16+8
 287 0016 1880     		strh	r0, [r3]
 108:Src/main.c    ****   Vout = adcBuffer[1] * 16.6f;
 288              		.loc 1 108 0
 289 0018 6088     		ldrh	r0, [r4, #2]
 290 001a FFF7FEFF 		bl	__aeabi_i2f
 291              	.LVL12:
 292 001e 1349     		ldr	r1, .L16+12
 293 0020 FFF7FEFF 		bl	__aeabi_fmul
 294              	.LVL13:
 295 0024 FFF7FEFF 		bl	__aeabi_f2uiz
 296              	.LVL14:
 297 0028 041C     		mov	r4, r0
 298 002a 114B     		ldr	r3, .L16+16
 299 002c 1860     		str	r0, [r3]
 109:Src/main.c    ****   int32_t error = Vset - Vout;
 300              		.loc 1 109 0
 301 002e 114B     		ldr	r3, .L16+20
 302 0030 1868     		ldr	r0, [r3]
 303 0032 001B     		sub	r0, r0, r4
ARM GAS  /tmp/cclyB5Uc.s 			page 19


 304              	.LVL15:
 111:Src/main.c    ****   TIM1->CCR1 = CLAMP(error / 3, 0, 500);
 305              		.loc 1 111 0
 306 0034 104B     		ldr	r3, .L16+24
 307 0036 9842     		cmp	r0, r3
 308 0038 07DC     		bgt	.L14
 111:Src/main.c    ****   TIM1->CCR1 = CLAMP(error / 3, 0, 500);
 309              		.loc 1 111 0 is_stmt 0 discriminator 1
 310 003a 831C     		add	r3, r0, #2
 311 003c 03DB     		blt	.L15
 111:Src/main.c    ****   TIM1->CCR1 = CLAMP(error / 3, 0, 500);
 312              		.loc 1 111 0 discriminator 3
 313 003e 0321     		mov	r1, #3
 314 0040 FFF7FEFF 		bl	__aeabi_idiv
 315              	.LVL16:
 316 0044 03E0     		b	.L11
 317              	.LVL17:
 318              	.L15:
 111:Src/main.c    ****   TIM1->CCR1 = CLAMP(error / 3, 0, 500);
 319              		.loc 1 111 0
 320 0046 0020     		mov	r0, #0
 321              	.LVL18:
 322 0048 01E0     		b	.L11
 323              	.LVL19:
 324              	.L14:
 325 004a FA20     		mov	r0, #250
 326              	.LVL20:
 327 004c 4000     		lsl	r0, r0, #1
 328              	.LVL21:
 329              	.L11:
 111:Src/main.c    ****   TIM1->CCR1 = CLAMP(error / 3, 0, 500);
 330              		.loc 1 111 0 discriminator 5
 331 004e 0B4B     		ldr	r3, .L16+28
 332 0050 5863     		str	r0, [r3, #52]
 113:Src/main.c    ****   if (Vout > 55000) {
 333              		.loc 1 113 0 is_stmt 1 discriminator 5
 334 0052 0B4B     		ldr	r3, .L16+32
 335 0054 9C42     		cmp	r4, r3
 336 0056 02D9     		bls	.L10
 114:Src/main.c    ****     TIM1->CCR1 = 0;
 337              		.loc 1 114 0
 338 0058 0022     		mov	r2, #0
 339 005a 084B     		ldr	r3, .L16+28
 340 005c 5A63     		str	r2, [r3, #52]
 341              	.L10:
 116:Src/main.c    **** }
 342              		.loc 1 116 0
 343              		@ sp needed
 344 005e 10BD     		pop	{r4, pc}
 345              	.L17:
 346              		.align	2
 347              	.L16:
 348 0060 00000000 		.word	adcBuffer
 349 0064 713DAA3F 		.word	1068121457
 350 0068 00000000 		.word	.LANCHOR0
 351 006c CDCC8441 		.word	1099222221
 352 0070 00000000 		.word	.LANCHOR1
ARM GAS  /tmp/cclyB5Uc.s 			page 20


 353 0074 00000000 		.word	.LANCHOR2
 354 0078 DE050000 		.word	1502
 355 007c 002C0140 		.word	1073818624
 356 0080 D8D60000 		.word	55000
 357              		.cfi_endproc
 358              	.LFE34:
 360              		.section	.text.dfu_otter_bootloader,"ax",%progbits
 361              		.align	2
 362              		.global	dfu_otter_bootloader
 363              		.code	16
 364              		.thumb_func
 366              	dfu_otter_bootloader:
 367              	.LFB35:
 121:Src/main.c    **** {
 368              		.loc 1 121 0
 369              		.cfi_startproc
 122:Src/main.c    ****   *((unsigned long *)0x20003FF0) = 0xDEADBEEF;
 370              		.loc 1 122 0
 371 0000 054A     		ldr	r2, .L20
 372 0002 064B     		ldr	r3, .L20+4
 373 0004 1A60     		str	r2, [r3]
 374              	.LBB21:
 375              	.LBB22:
 376              	.LBB23:
 377              	.LBB24:
 378              		.file 2 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS Cortex-M Core Function/Instruction Header File
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V4.30
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     20. October 2015
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:Drivers/CMSIS/Include/cmsis_gcc.h **** 
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****    All rights reserved.
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****    Redistribution and use in source and binary forms, with or without
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****    modification, are permitted provided that the following conditions are met:
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****    - Redistributions of source code must retain the above copyright
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****    - Redistributions in binary form must reproduce the above copyright
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer in the
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****      documentation and/or other materials provided with the distribution.
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****      to endorse or promote products derived from this software without
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****      specific prior written permission.
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****    *
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:Drivers/CMSIS/Include/cmsis_gcc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:Drivers/CMSIS/Include/cmsis_gcc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:Drivers/CMSIS/Include/cmsis_gcc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:Drivers/CMSIS/Include/cmsis_gcc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:Drivers/CMSIS/Include/cmsis_gcc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:Drivers/CMSIS/Include/cmsis_gcc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:Drivers/CMSIS/Include/cmsis_gcc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:Drivers/CMSIS/Include/cmsis_gcc.h ****    POSSIBILITY OF SUCH DAMAGE.
ARM GAS  /tmp/cclyB5Uc.s 			page 21


  32:Drivers/CMSIS/Include/cmsis_gcc.h ****    ---------------------------------------------------------------------------*/
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  36:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined ( __GNUC__ )
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  41:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  44:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  47:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  49:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
  51:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  53:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  54:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  55:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  57:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
  59:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  60:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  62:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  66:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  67:Drivers/CMSIS/Include/cmsis_gcc.h ****   Can only be executed in Privileged modes.
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  72:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  73:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  74:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  75:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
  77:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
  78:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  80:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
  81:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
  83:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
  85:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  87:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  88:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/cclyB5Uc.s 			page 22


  89:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
  93:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
  95:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  97:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  98:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  99:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 100:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 101:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 102:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 105:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
 106:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 108:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 109:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 110:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 111:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 114:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 115:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 116:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 117:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 118:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
 120:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 121:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 122:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 123:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 124:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 125:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 126:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 127:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 128:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 129:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 130:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 131:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 132:Drivers/CMSIS/Include/cmsis_gcc.h ****     \return               xPSR Register value
 133:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 134:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
 135:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 137:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 140:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 141:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 142:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 143:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 144:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 145:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
ARM GAS  /tmp/cclyB5Uc.s 			page 23


 146:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 148:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
 149:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 150:Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 151:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 152:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 154:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 155:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 156:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 157:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 158:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 159:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 160:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 161:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 162:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 163:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 164:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 165:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 168:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 169:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 170:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 171:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 172:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 175:Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 177:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 178:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 179:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 180:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 183:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 184:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 186:Drivers/CMSIS/Include/cmsis_gcc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 187:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 188:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 189:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 190:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 191:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 192:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 193:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 194:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 196:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 197:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 198:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 201:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 202:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/cclyB5Uc.s 			page 24


 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 205:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 206:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 210:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 211:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 212:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 213:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 214:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 215:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 216:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 217:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 218:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 219:Drivers/CMSIS/Include/cmsis_gcc.h **** #if       (__CORTEX_M >= 0x03U)
 220:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 221:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 222:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 223:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 224:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 225:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 226:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
 227:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 228:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 229:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 230:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 231:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 232:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 233:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 234:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 235:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 236:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 237:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
 238:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 239:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 240:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 241:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 242:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 243:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 244:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 245:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 246:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 247:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 248:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 249:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 250:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 251:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 252:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 253:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 254:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 255:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 256:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 257:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 258:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 259:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
ARM GAS  /tmp/cclyB5Uc.s 			page 25


 260:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 261:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 262:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
 263:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 264:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 265:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 266:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 267:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 268:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 269:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 270:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 271:Drivers/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 272:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 273:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 274:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
 275:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 276:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
 277:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 278:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 279:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 280:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 281:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 282:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 283:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 284:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 285:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 286:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 287:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 288:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 289:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 290:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 291:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 292:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 293:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 294:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 295:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 296:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 297:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 298:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 299:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 300:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 301:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 302:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 303:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 304:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* (__CORTEX_M >= 0x03U) */
 305:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 306:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 307:Drivers/CMSIS/Include/cmsis_gcc.h **** #if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
 308:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 309:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 310:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 311:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 312:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 313:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 314:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
 315:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 316:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
ARM GAS  /tmp/cclyB5Uc.s 			page 26


 317:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 318:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 319:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 320:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 321:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 322:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 323:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 324:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 325:Drivers/CMSIS/Include/cmsis_gcc.h ****    return(0);
 326:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 327:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 328:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 329:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 330:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 331:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 332:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 333:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 334:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 335:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 336:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 337:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 338:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 339:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 340:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
 341:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 342:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 343:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 344:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 345:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
 346:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 347:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 348:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 349:Drivers/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 350:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 351:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 352:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 353:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 354:Drivers/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 355:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 356:Drivers/CMSIS/Include/cmsis_gcc.h **** */
 357:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 358:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 359:Drivers/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 360:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 361:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 362:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 363:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 364:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 365:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 366:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 367:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 368:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 369:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 370:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 371:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 372:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 373:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
ARM GAS  /tmp/cclyB5Uc.s 			page 27


 374:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 375:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("nop");
 376:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 377:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 378:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 379:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 380:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 381:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 382:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 383:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 384:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 385:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("wfi");
 386:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 387:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 388:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 389:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 390:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 391:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 392:Drivers/CMSIS/Include/cmsis_gcc.h ****     a low-power state until one of a number of events occurs.
 393:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 394:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 395:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 396:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("wfe");
 397:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 398:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 399:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 400:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 401:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 402:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 403:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 404:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 405:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 406:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("sev");
 407:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 408:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 409:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 410:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 411:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 412:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 413:Drivers/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 414:Drivers/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 415:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 416:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 417:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 418:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 419:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 420:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 421:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 422:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 423:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 424:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 425:Drivers/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 426:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 427:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 428:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 429:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 379              		.loc 2 429 0
ARM GAS  /tmp/cclyB5Uc.s 			page 28


 380              	@ 429 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 381 0006 BFF34F8F 		dsb 0xF
 382              	@ 0 "" 2
 383              		.code	16
 384              	.LBE24:
 385              	.LBE23:
 386              		.file 3 "Drivers/CMSIS/Include/core_cm0.h"
   1:Drivers/CMSIS/Include/core_cm0.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/core_cm0.h ****  * @file     core_cm0.h
   3:Drivers/CMSIS/Include/core_cm0.h ****  * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
   4:Drivers/CMSIS/Include/core_cm0.h ****  * @version  V4.30
   5:Drivers/CMSIS/Include/core_cm0.h ****  * @date     20. October 2015
   6:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/core_cm0.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:Drivers/CMSIS/Include/core_cm0.h **** 
   9:Drivers/CMSIS/Include/core_cm0.h ****    All rights reserved.
  10:Drivers/CMSIS/Include/core_cm0.h ****    Redistribution and use in source and binary forms, with or without
  11:Drivers/CMSIS/Include/core_cm0.h ****    modification, are permitted provided that the following conditions are met:
  12:Drivers/CMSIS/Include/core_cm0.h ****    - Redistributions of source code must retain the above copyright
  13:Drivers/CMSIS/Include/core_cm0.h ****      notice, this list of conditions and the following disclaimer.
  14:Drivers/CMSIS/Include/core_cm0.h ****    - Redistributions in binary form must reproduce the above copyright
  15:Drivers/CMSIS/Include/core_cm0.h ****      notice, this list of conditions and the following disclaimer in the
  16:Drivers/CMSIS/Include/core_cm0.h ****      documentation and/or other materials provided with the distribution.
  17:Drivers/CMSIS/Include/core_cm0.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:Drivers/CMSIS/Include/core_cm0.h ****      to endorse or promote products derived from this software without
  19:Drivers/CMSIS/Include/core_cm0.h ****      specific prior written permission.
  20:Drivers/CMSIS/Include/core_cm0.h ****    *
  21:Drivers/CMSIS/Include/core_cm0.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:Drivers/CMSIS/Include/core_cm0.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:Drivers/CMSIS/Include/core_cm0.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:Drivers/CMSIS/Include/core_cm0.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:Drivers/CMSIS/Include/core_cm0.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:Drivers/CMSIS/Include/core_cm0.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:Drivers/CMSIS/Include/core_cm0.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:Drivers/CMSIS/Include/core_cm0.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:Drivers/CMSIS/Include/core_cm0.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:Drivers/CMSIS/Include/core_cm0.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:Drivers/CMSIS/Include/core_cm0.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:Drivers/CMSIS/Include/core_cm0.h ****    ---------------------------------------------------------------------------*/
  33:Drivers/CMSIS/Include/core_cm0.h **** 
  34:Drivers/CMSIS/Include/core_cm0.h **** 
  35:Drivers/CMSIS/Include/core_cm0.h **** #if   defined ( __ICCARM__ )
  36:Drivers/CMSIS/Include/core_cm0.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  37:Drivers/CMSIS/Include/core_cm0.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  38:Drivers/CMSIS/Include/core_cm0.h ****   #pragma clang system_header   /* treat file as system include file */
  39:Drivers/CMSIS/Include/core_cm0.h **** #endif
  40:Drivers/CMSIS/Include/core_cm0.h **** 
  41:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_GENERIC
  42:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_GENERIC
  43:Drivers/CMSIS/Include/core_cm0.h **** 
  44:Drivers/CMSIS/Include/core_cm0.h **** #include <stdint.h>
  45:Drivers/CMSIS/Include/core_cm0.h **** 
  46:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
  47:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
  48:Drivers/CMSIS/Include/core_cm0.h **** #endif
  49:Drivers/CMSIS/Include/core_cm0.h **** 
  50:Drivers/CMSIS/Include/core_cm0.h **** /**
ARM GAS  /tmp/cclyB5Uc.s 			page 29


  51:Drivers/CMSIS/Include/core_cm0.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  52:Drivers/CMSIS/Include/core_cm0.h ****   CMSIS violates the following MISRA-C:2004 rules:
  53:Drivers/CMSIS/Include/core_cm0.h **** 
  54:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  55:Drivers/CMSIS/Include/core_cm0.h ****      Function definitions in header files are used to allow 'inlining'.
  56:Drivers/CMSIS/Include/core_cm0.h **** 
  57:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  58:Drivers/CMSIS/Include/core_cm0.h ****      Unions are used for effective representation of core registers.
  59:Drivers/CMSIS/Include/core_cm0.h **** 
  60:Drivers/CMSIS/Include/core_cm0.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  61:Drivers/CMSIS/Include/core_cm0.h ****      Function-like macros are used to allow more efficient code.
  62:Drivers/CMSIS/Include/core_cm0.h ****  */
  63:Drivers/CMSIS/Include/core_cm0.h **** 
  64:Drivers/CMSIS/Include/core_cm0.h **** 
  65:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
  66:Drivers/CMSIS/Include/core_cm0.h ****  *                 CMSIS definitions
  67:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
  68:Drivers/CMSIS/Include/core_cm0.h **** /**
  69:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup Cortex_M0
  70:Drivers/CMSIS/Include/core_cm0.h ****   @{
  71:Drivers/CMSIS/Include/core_cm0.h ****  */
  72:Drivers/CMSIS/Include/core_cm0.h **** 
  73:Drivers/CMSIS/Include/core_cm0.h **** /*  CMSIS CM0 definitions */
  74:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS H
  75:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS H
  76:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
  77:Drivers/CMSIS/Include/core_cm0.h ****                                     __CM0_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL versi
  78:Drivers/CMSIS/Include/core_cm0.h **** 
  79:Drivers/CMSIS/Include/core_cm0.h **** #define __CORTEX_M                (0x00U)                                      /*!< Cortex-M Core *
  80:Drivers/CMSIS/Include/core_cm0.h **** 
  81:Drivers/CMSIS/Include/core_cm0.h **** 
  82:Drivers/CMSIS/Include/core_cm0.h **** #if   defined ( __CC_ARM )
  83:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  84:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  85:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static __inline
  86:Drivers/CMSIS/Include/core_cm0.h **** 
  87:Drivers/CMSIS/Include/core_cm0.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  88:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  89:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  90:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static __inline
  91:Drivers/CMSIS/Include/core_cm0.h **** 
  92:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __GNUC__ )
  93:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for GNU Comp
  94:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         inline                                     /*!< inline keyword for GNU C
  95:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
  96:Drivers/CMSIS/Include/core_cm0.h **** 
  97:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __ICCARM__ )
  98:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for IAR Comp
  99:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         inline                                     /*!< inline keyword for IAR C
 100:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
 101:Drivers/CMSIS/Include/core_cm0.h **** 
 102:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TMS470__ )
 103:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for TI CCS C
 104:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
 105:Drivers/CMSIS/Include/core_cm0.h **** 
 106:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TASKING__ )
 107:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for TASKING 
ARM GAS  /tmp/cclyB5Uc.s 			page 30


 108:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         inline                                     /*!< inline keyword for TASKI
 109:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
 110:Drivers/CMSIS/Include/core_cm0.h **** 
 111:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __CSMC__ )
 112:Drivers/CMSIS/Include/core_cm0.h ****   #define __packed
 113:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            _asm                                      /*!< asm keyword for COSMIC Co
 114:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         inline                                    /*!< inline keyword for COSMIC
 115:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
 116:Drivers/CMSIS/Include/core_cm0.h **** 
 117:Drivers/CMSIS/Include/core_cm0.h **** #else
 118:Drivers/CMSIS/Include/core_cm0.h ****   #error Unknown compiler
 119:Drivers/CMSIS/Include/core_cm0.h **** #endif
 120:Drivers/CMSIS/Include/core_cm0.h **** 
 121:Drivers/CMSIS/Include/core_cm0.h **** /** __FPU_USED indicates whether an FPU is used or not.
 122:Drivers/CMSIS/Include/core_cm0.h ****     This core does not support an FPU at all
 123:Drivers/CMSIS/Include/core_cm0.h **** */
 124:Drivers/CMSIS/Include/core_cm0.h **** #define __FPU_USED       0U
 125:Drivers/CMSIS/Include/core_cm0.h **** 
 126:Drivers/CMSIS/Include/core_cm0.h **** #if defined ( __CC_ARM )
 127:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TARGET_FPU_VFP
 128:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 129:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 130:Drivers/CMSIS/Include/core_cm0.h **** 
 131:Drivers/CMSIS/Include/core_cm0.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
 132:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARM_PCS_VFP
 133:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 134:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 135:Drivers/CMSIS/Include/core_cm0.h **** 
 136:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __GNUC__ )
 137:Drivers/CMSIS/Include/core_cm0.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 138:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 139:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 140:Drivers/CMSIS/Include/core_cm0.h **** 
 141:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __ICCARM__ )
 142:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARMVFP__
 143:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 144:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 145:Drivers/CMSIS/Include/core_cm0.h **** 
 146:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TMS470__ )
 147:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TI_VFP_SUPPORT__
 148:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 149:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 150:Drivers/CMSIS/Include/core_cm0.h **** 
 151:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TASKING__ )
 152:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __FPU_VFP__
 153:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 154:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 155:Drivers/CMSIS/Include/core_cm0.h **** 
 156:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __CSMC__ )
 157:Drivers/CMSIS/Include/core_cm0.h ****   #if ( __CSMC__ & 0x400U)
 158:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 159:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 160:Drivers/CMSIS/Include/core_cm0.h **** 
 161:Drivers/CMSIS/Include/core_cm0.h **** #endif
 162:Drivers/CMSIS/Include/core_cm0.h **** 
 163:Drivers/CMSIS/Include/core_cm0.h **** #include "core_cmInstr.h"                /* Core Instruction Access */
 164:Drivers/CMSIS/Include/core_cm0.h **** #include "core_cmFunc.h"                 /* Core Function Access */
ARM GAS  /tmp/cclyB5Uc.s 			page 31


 165:Drivers/CMSIS/Include/core_cm0.h **** 
 166:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 167:Drivers/CMSIS/Include/core_cm0.h **** }
 168:Drivers/CMSIS/Include/core_cm0.h **** #endif
 169:Drivers/CMSIS/Include/core_cm0.h **** 
 170:Drivers/CMSIS/Include/core_cm0.h **** #endif /* __CORE_CM0_H_GENERIC */
 171:Drivers/CMSIS/Include/core_cm0.h **** 
 172:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CMSIS_GENERIC
 173:Drivers/CMSIS/Include/core_cm0.h **** 
 174:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_DEPENDANT
 175:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_DEPENDANT
 176:Drivers/CMSIS/Include/core_cm0.h **** 
 177:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 178:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
 179:Drivers/CMSIS/Include/core_cm0.h **** #endif
 180:Drivers/CMSIS/Include/core_cm0.h **** 
 181:Drivers/CMSIS/Include/core_cm0.h **** /* check device defines and use defaults */
 182:Drivers/CMSIS/Include/core_cm0.h **** #if defined __CHECK_DEVICE_DEFINES
 183:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __CM0_REV
 184:Drivers/CMSIS/Include/core_cm0.h ****     #define __CM0_REV               0x0000U
 185:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__CM0_REV not defined in device header file; using default!"
 186:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 187:Drivers/CMSIS/Include/core_cm0.h **** 
 188:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __NVIC_PRIO_BITS
 189:Drivers/CMSIS/Include/core_cm0.h ****     #define __NVIC_PRIO_BITS          2U
 190:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 191:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 192:Drivers/CMSIS/Include/core_cm0.h **** 
 193:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __Vendor_SysTickConfig
 194:Drivers/CMSIS/Include/core_cm0.h ****     #define __Vendor_SysTickConfig    0U
 195:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 196:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 197:Drivers/CMSIS/Include/core_cm0.h **** #endif
 198:Drivers/CMSIS/Include/core_cm0.h **** 
 199:Drivers/CMSIS/Include/core_cm0.h **** /* IO definitions (access restrictions to peripheral registers) */
 200:Drivers/CMSIS/Include/core_cm0.h **** /**
 201:Drivers/CMSIS/Include/core_cm0.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 202:Drivers/CMSIS/Include/core_cm0.h **** 
 203:Drivers/CMSIS/Include/core_cm0.h ****     <strong>IO Type Qualifiers</strong> are used
 204:Drivers/CMSIS/Include/core_cm0.h ****     \li to specify the access to peripheral variables.
 205:Drivers/CMSIS/Include/core_cm0.h ****     \li for automatic generation of peripheral register debug information.
 206:Drivers/CMSIS/Include/core_cm0.h **** */
 207:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 208:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 209:Drivers/CMSIS/Include/core_cm0.h **** #else
 210:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 211:Drivers/CMSIS/Include/core_cm0.h **** #endif
 212:Drivers/CMSIS/Include/core_cm0.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 213:Drivers/CMSIS/Include/core_cm0.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 214:Drivers/CMSIS/Include/core_cm0.h **** 
 215:Drivers/CMSIS/Include/core_cm0.h **** /* following defines should be used for structure members */
 216:Drivers/CMSIS/Include/core_cm0.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 217:Drivers/CMSIS/Include/core_cm0.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 218:Drivers/CMSIS/Include/core_cm0.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 219:Drivers/CMSIS/Include/core_cm0.h **** 
 220:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group Cortex_M0 */
 221:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/cclyB5Uc.s 			page 32


 222:Drivers/CMSIS/Include/core_cm0.h **** 
 223:Drivers/CMSIS/Include/core_cm0.h **** 
 224:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 225:Drivers/CMSIS/Include/core_cm0.h ****  *                 Register Abstraction
 226:Drivers/CMSIS/Include/core_cm0.h ****   Core Register contain:
 227:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register
 228:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Register
 229:Drivers/CMSIS/Include/core_cm0.h ****   - Core SCB Register
 230:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Register
 231:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 232:Drivers/CMSIS/Include/core_cm0.h **** /**
 233:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 234:Drivers/CMSIS/Include/core_cm0.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 235:Drivers/CMSIS/Include/core_cm0.h **** */
 236:Drivers/CMSIS/Include/core_cm0.h **** 
 237:Drivers/CMSIS/Include/core_cm0.h **** /**
 238:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 239:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 240:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Core Register type definitions.
 241:Drivers/CMSIS/Include/core_cm0.h ****   @{
 242:Drivers/CMSIS/Include/core_cm0.h ****  */
 243:Drivers/CMSIS/Include/core_cm0.h **** 
 244:Drivers/CMSIS/Include/core_cm0.h **** /**
 245:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 246:Drivers/CMSIS/Include/core_cm0.h ****  */
 247:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 248:Drivers/CMSIS/Include/core_cm0.h **** {
 249:Drivers/CMSIS/Include/core_cm0.h ****   struct
 250:Drivers/CMSIS/Include/core_cm0.h ****   {
 251:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 252:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 253:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 254:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 255:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 256:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 257:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 258:Drivers/CMSIS/Include/core_cm0.h **** } APSR_Type;
 259:Drivers/CMSIS/Include/core_cm0.h **** 
 260:Drivers/CMSIS/Include/core_cm0.h **** /* APSR Register Definitions */
 261:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 262:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 263:Drivers/CMSIS/Include/core_cm0.h **** 
 264:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 265:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 266:Drivers/CMSIS/Include/core_cm0.h **** 
 267:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 268:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 269:Drivers/CMSIS/Include/core_cm0.h **** 
 270:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 271:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 272:Drivers/CMSIS/Include/core_cm0.h **** 
 273:Drivers/CMSIS/Include/core_cm0.h **** 
 274:Drivers/CMSIS/Include/core_cm0.h **** /**
 275:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 276:Drivers/CMSIS/Include/core_cm0.h ****  */
 277:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 278:Drivers/CMSIS/Include/core_cm0.h **** {
ARM GAS  /tmp/cclyB5Uc.s 			page 33


 279:Drivers/CMSIS/Include/core_cm0.h ****   struct
 280:Drivers/CMSIS/Include/core_cm0.h ****   {
 281:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 282:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 283:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 284:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 285:Drivers/CMSIS/Include/core_cm0.h **** } IPSR_Type;
 286:Drivers/CMSIS/Include/core_cm0.h **** 
 287:Drivers/CMSIS/Include/core_cm0.h **** /* IPSR Register Definitions */
 288:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 289:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 290:Drivers/CMSIS/Include/core_cm0.h **** 
 291:Drivers/CMSIS/Include/core_cm0.h **** 
 292:Drivers/CMSIS/Include/core_cm0.h **** /**
 293:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 294:Drivers/CMSIS/Include/core_cm0.h ****  */
 295:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 296:Drivers/CMSIS/Include/core_cm0.h **** {
 297:Drivers/CMSIS/Include/core_cm0.h ****   struct
 298:Drivers/CMSIS/Include/core_cm0.h ****   {
 299:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 300:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 301:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 302:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 303:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 304:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 305:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 306:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 307:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 308:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 309:Drivers/CMSIS/Include/core_cm0.h **** } xPSR_Type;
 310:Drivers/CMSIS/Include/core_cm0.h **** 
 311:Drivers/CMSIS/Include/core_cm0.h **** /* xPSR Register Definitions */
 312:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 313:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 314:Drivers/CMSIS/Include/core_cm0.h **** 
 315:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 316:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 317:Drivers/CMSIS/Include/core_cm0.h **** 
 318:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 319:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 320:Drivers/CMSIS/Include/core_cm0.h **** 
 321:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 322:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 323:Drivers/CMSIS/Include/core_cm0.h **** 
 324:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 325:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 326:Drivers/CMSIS/Include/core_cm0.h **** 
 327:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 328:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 329:Drivers/CMSIS/Include/core_cm0.h **** 
 330:Drivers/CMSIS/Include/core_cm0.h **** 
 331:Drivers/CMSIS/Include/core_cm0.h **** /**
 332:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Control Registers (CONTROL).
 333:Drivers/CMSIS/Include/core_cm0.h ****  */
 334:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 335:Drivers/CMSIS/Include/core_cm0.h **** {
ARM GAS  /tmp/cclyB5Uc.s 			page 34


 336:Drivers/CMSIS/Include/core_cm0.h ****   struct
 337:Drivers/CMSIS/Include/core_cm0.h ****   {
 338:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
 339:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 340:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 341:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 342:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 343:Drivers/CMSIS/Include/core_cm0.h **** } CONTROL_Type;
 344:Drivers/CMSIS/Include/core_cm0.h **** 
 345:Drivers/CMSIS/Include/core_cm0.h **** /* CONTROL Register Definitions */
 346:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 347:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 348:Drivers/CMSIS/Include/core_cm0.h **** 
 349:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CORE */
 350:Drivers/CMSIS/Include/core_cm0.h **** 
 351:Drivers/CMSIS/Include/core_cm0.h **** 
 352:Drivers/CMSIS/Include/core_cm0.h **** /**
 353:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 354:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 355:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Type definitions for the NVIC Registers
 356:Drivers/CMSIS/Include/core_cm0.h ****   @{
 357:Drivers/CMSIS/Include/core_cm0.h ****  */
 358:Drivers/CMSIS/Include/core_cm0.h **** 
 359:Drivers/CMSIS/Include/core_cm0.h **** /**
 360:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 361:Drivers/CMSIS/Include/core_cm0.h ****  */
 362:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 363:Drivers/CMSIS/Include/core_cm0.h **** {
 364:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 365:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0[31U];
 366:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 367:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RSERVED1[31U];
 368:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 369:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED2[31U];
 370:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 371:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED3[31U];
 372:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED4[64U];
 373:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 374:Drivers/CMSIS/Include/core_cm0.h **** }  NVIC_Type;
 375:Drivers/CMSIS/Include/core_cm0.h **** 
 376:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_NVIC */
 377:Drivers/CMSIS/Include/core_cm0.h **** 
 378:Drivers/CMSIS/Include/core_cm0.h **** 
 379:Drivers/CMSIS/Include/core_cm0.h **** /**
 380:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 381:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 382:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Control Block Registers
 383:Drivers/CMSIS/Include/core_cm0.h ****   @{
 384:Drivers/CMSIS/Include/core_cm0.h ****  */
 385:Drivers/CMSIS/Include/core_cm0.h **** 
 386:Drivers/CMSIS/Include/core_cm0.h **** /**
 387:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Control Block (SCB).
 388:Drivers/CMSIS/Include/core_cm0.h ****  */
 389:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 390:Drivers/CMSIS/Include/core_cm0.h **** {
 391:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 392:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
ARM GAS  /tmp/cclyB5Uc.s 			page 35


 393:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0;
 394:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 395:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 396:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 397:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED1;
 398:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 399:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 400:Drivers/CMSIS/Include/core_cm0.h **** } SCB_Type;
 401:Drivers/CMSIS/Include/core_cm0.h **** 
 402:Drivers/CMSIS/Include/core_cm0.h **** /* SCB CPUID Register Definitions */
 403:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 404:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 405:Drivers/CMSIS/Include/core_cm0.h **** 
 406:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 407:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 408:Drivers/CMSIS/Include/core_cm0.h **** 
 409:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 410:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 411:Drivers/CMSIS/Include/core_cm0.h **** 
 412:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 413:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 414:Drivers/CMSIS/Include/core_cm0.h **** 
 415:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 416:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 417:Drivers/CMSIS/Include/core_cm0.h **** 
 418:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Interrupt Control State Register Definitions */
 419:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 420:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 421:Drivers/CMSIS/Include/core_cm0.h **** 
 422:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 423:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 424:Drivers/CMSIS/Include/core_cm0.h **** 
 425:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 426:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 427:Drivers/CMSIS/Include/core_cm0.h **** 
 428:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 429:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 430:Drivers/CMSIS/Include/core_cm0.h **** 
 431:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 432:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 433:Drivers/CMSIS/Include/core_cm0.h **** 
 434:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 435:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 436:Drivers/CMSIS/Include/core_cm0.h **** 
 437:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 438:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 439:Drivers/CMSIS/Include/core_cm0.h **** 
 440:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 441:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 442:Drivers/CMSIS/Include/core_cm0.h **** 
 443:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 444:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 445:Drivers/CMSIS/Include/core_cm0.h **** 
 446:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 447:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 448:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 449:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/cclyB5Uc.s 			page 36


 450:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 451:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 452:Drivers/CMSIS/Include/core_cm0.h **** 
 453:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 454:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 455:Drivers/CMSIS/Include/core_cm0.h **** 
 456:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 457:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 458:Drivers/CMSIS/Include/core_cm0.h **** 
 459:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 460:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 461:Drivers/CMSIS/Include/core_cm0.h **** 
 462:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Control Register Definitions */
 463:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 464:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 465:Drivers/CMSIS/Include/core_cm0.h **** 
 466:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 467:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 468:Drivers/CMSIS/Include/core_cm0.h **** 
 469:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 470:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 471:Drivers/CMSIS/Include/core_cm0.h **** 
 472:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Configuration Control Register Definitions */
 473:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 474:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 475:Drivers/CMSIS/Include/core_cm0.h **** 
 476:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 477:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 478:Drivers/CMSIS/Include/core_cm0.h **** 
 479:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Handler Control and State Register Definitions */
 480:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 481:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 482:Drivers/CMSIS/Include/core_cm0.h **** 
 483:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SCB */
 484:Drivers/CMSIS/Include/core_cm0.h **** 
 485:Drivers/CMSIS/Include/core_cm0.h **** 
 486:Drivers/CMSIS/Include/core_cm0.h **** /**
 487:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 488:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 489:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Timer Registers.
 490:Drivers/CMSIS/Include/core_cm0.h ****   @{
 491:Drivers/CMSIS/Include/core_cm0.h ****  */
 492:Drivers/CMSIS/Include/core_cm0.h **** 
 493:Drivers/CMSIS/Include/core_cm0.h **** /**
 494:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Timer (SysTick).
 495:Drivers/CMSIS/Include/core_cm0.h ****  */
 496:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 497:Drivers/CMSIS/Include/core_cm0.h **** {
 498:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 499:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 500:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 501:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 502:Drivers/CMSIS/Include/core_cm0.h **** } SysTick_Type;
 503:Drivers/CMSIS/Include/core_cm0.h **** 
 504:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Control / Status Register Definitions */
 505:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 506:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
ARM GAS  /tmp/cclyB5Uc.s 			page 37


 507:Drivers/CMSIS/Include/core_cm0.h **** 
 508:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 509:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 510:Drivers/CMSIS/Include/core_cm0.h **** 
 511:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 512:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 513:Drivers/CMSIS/Include/core_cm0.h **** 
 514:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 515:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 516:Drivers/CMSIS/Include/core_cm0.h **** 
 517:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Reload Register Definitions */
 518:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 519:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 520:Drivers/CMSIS/Include/core_cm0.h **** 
 521:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Current Register Definitions */
 522:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 523:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 524:Drivers/CMSIS/Include/core_cm0.h **** 
 525:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Calibration Register Definitions */
 526:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 527:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 528:Drivers/CMSIS/Include/core_cm0.h **** 
 529:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 530:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 531:Drivers/CMSIS/Include/core_cm0.h **** 
 532:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 533:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 534:Drivers/CMSIS/Include/core_cm0.h **** 
 535:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SysTick */
 536:Drivers/CMSIS/Include/core_cm0.h **** 
 537:Drivers/CMSIS/Include/core_cm0.h **** 
 538:Drivers/CMSIS/Include/core_cm0.h **** /**
 539:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 540:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 541:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ove
 542:Drivers/CMSIS/Include/core_cm0.h ****             Therefore they are not covered by the Cortex-M0 header file.
 543:Drivers/CMSIS/Include/core_cm0.h ****   @{
 544:Drivers/CMSIS/Include/core_cm0.h ****  */
 545:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CoreDebug */
 546:Drivers/CMSIS/Include/core_cm0.h **** 
 547:Drivers/CMSIS/Include/core_cm0.h **** 
 548:Drivers/CMSIS/Include/core_cm0.h **** /**
 549:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 550:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 551:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 552:Drivers/CMSIS/Include/core_cm0.h ****   @{
 553:Drivers/CMSIS/Include/core_cm0.h ****  */
 554:Drivers/CMSIS/Include/core_cm0.h **** 
 555:Drivers/CMSIS/Include/core_cm0.h **** /**
 556:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 557:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 558:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of the bit field.
 559:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted value.
 560:Drivers/CMSIS/Include/core_cm0.h **** */
 561:Drivers/CMSIS/Include/core_cm0.h **** #define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
 562:Drivers/CMSIS/Include/core_cm0.h **** 
 563:Drivers/CMSIS/Include/core_cm0.h **** /**
ARM GAS  /tmp/cclyB5Uc.s 			page 38


 564:Drivers/CMSIS/Include/core_cm0.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 565:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 566:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of register.
 567:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted bit field value.
 568:Drivers/CMSIS/Include/core_cm0.h **** */
 569:Drivers/CMSIS/Include/core_cm0.h **** #define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
 570:Drivers/CMSIS/Include/core_cm0.h **** 
 571:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_core_bitfield */
 572:Drivers/CMSIS/Include/core_cm0.h **** 
 573:Drivers/CMSIS/Include/core_cm0.h **** 
 574:Drivers/CMSIS/Include/core_cm0.h **** /**
 575:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 576:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_base     Core Definitions
 577:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Definitions for base addresses, unions, and structures.
 578:Drivers/CMSIS/Include/core_cm0.h ****   @{
 579:Drivers/CMSIS/Include/core_cm0.h ****  */
 580:Drivers/CMSIS/Include/core_cm0.h **** 
 581:Drivers/CMSIS/Include/core_cm0.h **** /* Memory mapping of Cortex-M0 Hardware */
 582:Drivers/CMSIS/Include/core_cm0.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 583:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 584:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 585:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 586:Drivers/CMSIS/Include/core_cm0.h **** 
 587:Drivers/CMSIS/Include/core_cm0.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 588:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 589:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 590:Drivers/CMSIS/Include/core_cm0.h **** 
 591:Drivers/CMSIS/Include/core_cm0.h **** 
 592:Drivers/CMSIS/Include/core_cm0.h **** /*@} */
 593:Drivers/CMSIS/Include/core_cm0.h **** 
 594:Drivers/CMSIS/Include/core_cm0.h **** 
 595:Drivers/CMSIS/Include/core_cm0.h **** 
 596:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 597:Drivers/CMSIS/Include/core_cm0.h ****  *                Hardware Abstraction Layer
 598:Drivers/CMSIS/Include/core_cm0.h ****   Core Function Interface contains:
 599:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Functions
 600:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Functions
 601:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register Access Functions
 602:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 603:Drivers/CMSIS/Include/core_cm0.h **** /**
 604:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 605:Drivers/CMSIS/Include/core_cm0.h **** */
 606:Drivers/CMSIS/Include/core_cm0.h **** 
 607:Drivers/CMSIS/Include/core_cm0.h **** 
 608:Drivers/CMSIS/Include/core_cm0.h **** 
 609:Drivers/CMSIS/Include/core_cm0.h **** /* ##########################   NVIC functions  #################################### */
 610:Drivers/CMSIS/Include/core_cm0.h **** /**
 611:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_Core_FunctionInterface
 612:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 613:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 614:Drivers/CMSIS/Include/core_cm0.h ****   @{
 615:Drivers/CMSIS/Include/core_cm0.h ****  */
 616:Drivers/CMSIS/Include/core_cm0.h **** 
 617:Drivers/CMSIS/Include/core_cm0.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 618:Drivers/CMSIS/Include/core_cm0.h **** /* The following MACROS handle generation of the register offset and byte masks */
 619:Drivers/CMSIS/Include/core_cm0.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 620:Drivers/CMSIS/Include/core_cm0.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
ARM GAS  /tmp/cclyB5Uc.s 			page 39


 621:Drivers/CMSIS/Include/core_cm0.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 622:Drivers/CMSIS/Include/core_cm0.h **** 
 623:Drivers/CMSIS/Include/core_cm0.h **** 
 624:Drivers/CMSIS/Include/core_cm0.h **** /**
 625:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Enable External Interrupt
 626:Drivers/CMSIS/Include/core_cm0.h ****   \details Enables a device-specific interrupt in the NVIC interrupt controller.
 627:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  External interrupt number. Value cannot be negative.
 628:Drivers/CMSIS/Include/core_cm0.h ****  */
 629:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
 630:Drivers/CMSIS/Include/core_cm0.h **** {
 631:Drivers/CMSIS/Include/core_cm0.h ****   NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 632:Drivers/CMSIS/Include/core_cm0.h **** }
 633:Drivers/CMSIS/Include/core_cm0.h **** 
 634:Drivers/CMSIS/Include/core_cm0.h **** 
 635:Drivers/CMSIS/Include/core_cm0.h **** /**
 636:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Disable External Interrupt
 637:Drivers/CMSIS/Include/core_cm0.h ****   \details Disables a device-specific interrupt in the NVIC interrupt controller.
 638:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  External interrupt number. Value cannot be negative.
 639:Drivers/CMSIS/Include/core_cm0.h ****  */
 640:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
 641:Drivers/CMSIS/Include/core_cm0.h **** {
 642:Drivers/CMSIS/Include/core_cm0.h ****   NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 643:Drivers/CMSIS/Include/core_cm0.h **** }
 644:Drivers/CMSIS/Include/core_cm0.h **** 
 645:Drivers/CMSIS/Include/core_cm0.h **** 
 646:Drivers/CMSIS/Include/core_cm0.h **** /**
 647:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Pending Interrupt
 648:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the pending register in the NVIC and returns the pending bit for the specified int
 649:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 650:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt status is not pending.
 651:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt status is pending.
 652:Drivers/CMSIS/Include/core_cm0.h ****  */
 653:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
 654:Drivers/CMSIS/Include/core_cm0.h **** {
 655:Drivers/CMSIS/Include/core_cm0.h ****   return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL
 656:Drivers/CMSIS/Include/core_cm0.h **** }
 657:Drivers/CMSIS/Include/core_cm0.h **** 
 658:Drivers/CMSIS/Include/core_cm0.h **** 
 659:Drivers/CMSIS/Include/core_cm0.h **** /**
 660:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Pending Interrupt
 661:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the pending bit of an external interrupt.
 662:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number. Value cannot be negative.
 663:Drivers/CMSIS/Include/core_cm0.h ****  */
 664:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
 665:Drivers/CMSIS/Include/core_cm0.h **** {
 666:Drivers/CMSIS/Include/core_cm0.h ****   NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 667:Drivers/CMSIS/Include/core_cm0.h **** }
 668:Drivers/CMSIS/Include/core_cm0.h **** 
 669:Drivers/CMSIS/Include/core_cm0.h **** 
 670:Drivers/CMSIS/Include/core_cm0.h **** /**
 671:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Clear Pending Interrupt
 672:Drivers/CMSIS/Include/core_cm0.h ****   \details Clears the pending bit of an external interrupt.
 673:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  External interrupt number. Value cannot be negative.
 674:Drivers/CMSIS/Include/core_cm0.h ****  */
 675:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 676:Drivers/CMSIS/Include/core_cm0.h **** {
 677:Drivers/CMSIS/Include/core_cm0.h ****   NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
ARM GAS  /tmp/cclyB5Uc.s 			page 40


 678:Drivers/CMSIS/Include/core_cm0.h **** }
 679:Drivers/CMSIS/Include/core_cm0.h **** 
 680:Drivers/CMSIS/Include/core_cm0.h **** 
 681:Drivers/CMSIS/Include/core_cm0.h **** /**
 682:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Interrupt Priority
 683:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the priority of an interrupt.
 684:Drivers/CMSIS/Include/core_cm0.h ****   \note    The priority cannot be set for every core interrupt.
 685:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 686:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]  priority  Priority to set.
 687:Drivers/CMSIS/Include/core_cm0.h ****  */
 688:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 689:Drivers/CMSIS/Include/core_cm0.h **** {
 690:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) < 0)
 691:Drivers/CMSIS/Include/core_cm0.h ****   {
 692:Drivers/CMSIS/Include/core_cm0.h ****     SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))
 693:Drivers/CMSIS/Include/core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 694:Drivers/CMSIS/Include/core_cm0.h ****   }
 695:Drivers/CMSIS/Include/core_cm0.h ****   else
 696:Drivers/CMSIS/Include/core_cm0.h ****   {
 697:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 698:Drivers/CMSIS/Include/core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 699:Drivers/CMSIS/Include/core_cm0.h ****   }
 700:Drivers/CMSIS/Include/core_cm0.h **** }
 701:Drivers/CMSIS/Include/core_cm0.h **** 
 702:Drivers/CMSIS/Include/core_cm0.h **** 
 703:Drivers/CMSIS/Include/core_cm0.h **** /**
 704:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Interrupt Priority
 705:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the priority of an interrupt.
 706:Drivers/CMSIS/Include/core_cm0.h ****            The interrupt number can be positive to specify an external (device specific) interrupt,
 707:Drivers/CMSIS/Include/core_cm0.h ****            or negative to specify an internal (core) interrupt.
 708:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]   IRQn  Interrupt number.
 709:Drivers/CMSIS/Include/core_cm0.h ****   \return             Interrupt Priority.
 710:Drivers/CMSIS/Include/core_cm0.h ****                       Value is aligned automatically to the implemented priority bits of the microc
 711:Drivers/CMSIS/Include/core_cm0.h ****  */
 712:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
 713:Drivers/CMSIS/Include/core_cm0.h **** {
 714:Drivers/CMSIS/Include/core_cm0.h **** 
 715:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) < 0)
 716:Drivers/CMSIS/Include/core_cm0.h ****   {
 717:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 718:Drivers/CMSIS/Include/core_cm0.h ****   }
 719:Drivers/CMSIS/Include/core_cm0.h ****   else
 720:Drivers/CMSIS/Include/core_cm0.h ****   {
 721:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 722:Drivers/CMSIS/Include/core_cm0.h ****   }
 723:Drivers/CMSIS/Include/core_cm0.h **** }
 724:Drivers/CMSIS/Include/core_cm0.h **** 
 725:Drivers/CMSIS/Include/core_cm0.h **** 
 726:Drivers/CMSIS/Include/core_cm0.h **** /**
 727:Drivers/CMSIS/Include/core_cm0.h ****   \brief   System Reset
 728:Drivers/CMSIS/Include/core_cm0.h ****   \details Initiates a system reset request to reset the MCU.
 729:Drivers/CMSIS/Include/core_cm0.h ****  */
 730:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_SystemReset(void)
 731:Drivers/CMSIS/Include/core_cm0.h **** {
 732:Drivers/CMSIS/Include/core_cm0.h ****   __DSB();                                                          /* Ensure all outstanding memor
 733:Drivers/CMSIS/Include/core_cm0.h ****                                                                        buffered write are completed
 734:Drivers/CMSIS/Include/core_cm0.h ****   SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
ARM GAS  /tmp/cclyB5Uc.s 			page 41


 387              		.loc 3 734 0
 388 000a 054A     		ldr	r2, .L20+8
 389 000c 054B     		ldr	r3, .L20+12
 390 000e DA60     		str	r2, [r3, #12]
 391              	.LBB25:
 392              	.LBB26:
 393              		.loc 2 429 0
 394              	@ 429 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 395 0010 BFF34F8F 		dsb 0xF
 396              	@ 0 "" 2
 397              		.code	16
 398              	.L19:
 399              	.LBE26:
 400              	.LBE25:
 401              	.LBB27:
 402              	.LBB28:
 375:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("nop");
 403              		.loc 2 375 0
 404              	@ 375 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 405 0014 C046     		nop
 406              	@ 0 "" 2
 407              		.code	16
 408 0016 FDE7     		b	.L19
 409              	.L21:
 410              		.align	2
 411              	.L20:
 412 0018 EFBEADDE 		.word	-559038737
 413 001c F03F0020 		.word	536887280
 414 0020 0400FA05 		.word	100270084
 415 0024 00ED00E0 		.word	-536810240
 416              	.LBE28:
 417              	.LBE27:
 418              	.LBE22:
 419              	.LBE21:
 420              		.cfi_endproc
 421              	.LFE35:
 423              		.global	__aeabi_uidiv
 424              		.section	.text.HAL_TIM_PeriodElapsedCallback,"ax",%progbits
 425              		.align	2
 426              		.global	HAL_TIM_PeriodElapsedCallback
 427              		.code	16
 428              		.thumb_func
 430              	HAL_TIM_PeriodElapsedCallback:
 431              	.LFB36:
 133:Src/main.c    **** {
 432              		.loc 1 133 0
 433              		.cfi_startproc
 434              	.LVL22:
 435 0000 38B5     		push	{r3, r4, r5, lr}
 436              	.LCFI7:
 437              		.cfi_def_cfa_offset 16
 438              		.cfi_offset 3, -16
 439              		.cfi_offset 4, -12
 440              		.cfi_offset 5, -8
 441              		.cfi_offset 14, -4
 442 0002 041C     		mov	r4, r0
 134:Src/main.c    **** 	if(htim->Instance == TIM14)
ARM GAS  /tmp/cclyB5Uc.s 			page 42


 443              		.loc 1 134 0
 444 0004 1B4B     		ldr	r3, .L28
 445 0006 0268     		ldr	r2, [r0]
 446 0008 9A42     		cmp	r2, r3
 447 000a 1ED1     		bne	.L23
 137:Src/main.c    ****     if (TIM2->CNT == 0) {
 448              		.loc 1 137 0
 449 000c 8023     		mov	r3, #128
 450 000e DB05     		lsl	r3, r3, #23
 451 0010 5B6A     		ldr	r3, [r3, #36]
 452 0012 002B     		cmp	r3, #0
 453 0014 19D1     		bne	.L23
 138:Src/main.c    ****       TIM2->ARR = (uint32_t)(curPeriode0 / CLAMP(((Iout/200)-10), 3, 16)); // Play first channel
 454              		.loc 1 138 0
 455 0016 184B     		ldr	r3, .L28+4
 456 0018 1D68     		ldr	r5, [r3]
 457 001a 184B     		ldr	r3, .L28+8
 458 001c 1888     		ldrh	r0, [r3]
 459              	.LVL23:
 460 001e C821     		mov	r1, #200
 461 0020 FFF7FEFF 		bl	__aeabi_uidiv
 462              	.LVL24:
 463 0024 81B2     		uxth	r1, r0
 464 0026 0A39     		sub	r1, r1, #10
 465 0028 1029     		cmp	r1, #16
 466 002a 03DC     		bgt	.L27
 138:Src/main.c    ****       TIM2->ARR = (uint32_t)(curPeriode0 / CLAMP(((Iout/200)-10), 3, 16)); // Play first channel
 467              		.loc 1 138 0 is_stmt 0 discriminator 1
 468 002c 0329     		cmp	r1, #3
 469 002e 02DA     		bge	.L24
 470 0030 0321     		mov	r1, #3
 471 0032 00E0     		b	.L24
 472              	.L27:
 138:Src/main.c    ****       TIM2->ARR = (uint32_t)(curPeriode0 / CLAMP(((Iout/200)-10), 3, 16)); // Play first channel
 473              		.loc 1 138 0
 474 0034 1021     		mov	r1, #16
 475              	.L24:
 138:Src/main.c    ****       TIM2->ARR = (uint32_t)(curPeriode0 / CLAMP(((Iout/200)-10), 3, 16)); // Play first channel
 476              		.loc 1 138 0 discriminator 3
 477 0036 281C     		mov	r0, r5
 478 0038 FFF7FEFF 		bl	__aeabi_uidiv
 479              	.LVL25:
 480 003c 8023     		mov	r3, #128
 481 003e DB05     		lsl	r3, r3, #23
 482 0040 D862     		str	r0, [r3, #44]
 139:Src/main.c    ****     	TIM2->CR1 = TIM2->CR1 | 1;
 483              		.loc 1 139 0 is_stmt 1 discriminator 3
 484 0042 1968     		ldr	r1, [r3]
 485 0044 0122     		mov	r2, #1
 486 0046 0A43     		orr	r2, r1
 487 0048 1A60     		str	r2, [r3]
 488              	.L23:
 142:Src/main.c    **** 	if(htim->Instance == TIM15)
 489              		.loc 1 142 0
 490 004a 2268     		ldr	r2, [r4]
 491 004c 0C4B     		ldr	r3, .L28+12
 492 004e 9A42     		cmp	r2, r3
ARM GAS  /tmp/cclyB5Uc.s 			page 43


 493 0050 0ED1     		bne	.L22
 145:Src/main.c    ****     if (TIM2->CNT == 0) {
 494              		.loc 1 145 0
 495 0052 8023     		mov	r3, #128
 496 0054 DB05     		lsl	r3, r3, #23
 497 0056 5B6A     		ldr	r3, [r3, #36]
 498 0058 002B     		cmp	r3, #0
 499 005a 09D1     		bne	.L22
 146:Src/main.c    ****     	TIM2->ARR = (uint32_t)(curPeriode1 / 8); // Play second channel with less power
 500              		.loc 1 146 0
 501 005c 094B     		ldr	r3, .L28+16
 502 005e 1A68     		ldr	r2, [r3]
 503 0060 D208     		lsr	r2, r2, #3
 504 0062 8023     		mov	r3, #128
 505 0064 DB05     		lsl	r3, r3, #23
 506 0066 DA62     		str	r2, [r3, #44]
 147:Src/main.c    ****     	TIM2->CR1 = TIM2->CR1 | 1;
 507              		.loc 1 147 0
 508 0068 1968     		ldr	r1, [r3]
 509 006a 0122     		mov	r2, #1
 510 006c 0A43     		orr	r2, r1
 511 006e 1A60     		str	r2, [r3]
 512              	.L22:
 150:Src/main.c    **** }
 513              		.loc 1 150 0
 514              		@ sp needed
 515              	.LVL26:
 516 0070 38BD     		pop	{r3, r4, r5, pc}
 517              	.L29:
 518 0072 C046     		.align	2
 519              	.L28:
 520 0074 00200040 		.word	1073750016
 521 0078 00000000 		.word	.LANCHOR3
 522 007c 00000000 		.word	.LANCHOR0
 523 0080 00400140 		.word	1073823744
 524 0084 00000000 		.word	.LANCHOR4
 525              		.cfi_endproc
 526              	.LFE36:
 528              		.section	.text._Error_Handler,"ax",%progbits
 529              		.align	2
 530              		.global	_Error_Handler
 531              		.code	16
 532              		.thumb_func
 534              	_Error_Handler:
 535              	.LFB48:
 703:Src/main.c    **** 
 704:Src/main.c    **** /* USER CODE BEGIN 4 */
 705:Src/main.c    **** 
 706:Src/main.c    **** /* USER CODE END 4 */
 707:Src/main.c    **** 
 708:Src/main.c    **** /**
 709:Src/main.c    ****   * @brief  This function is executed in case of error occurrence.
 710:Src/main.c    ****   * @param  file: The file name as string.
 711:Src/main.c    ****   * @param  line: The line in file as a number.
 712:Src/main.c    ****   * @retval None
 713:Src/main.c    ****   */
 714:Src/main.c    **** void _Error_Handler(char *file, int line)
ARM GAS  /tmp/cclyB5Uc.s 			page 44


 715:Src/main.c    **** {
 536              		.loc 1 715 0
 537              		.cfi_startproc
 538              	.LVL27:
 539              	.L31:
 540 0000 FEE7     		b	.L31
 541              		.cfi_endproc
 542              	.LFE48:
 544 0002 C046     		.section	.text.MX_DAC_Init,"ax",%progbits
 545              		.align	2
 546              		.code	16
 547              		.thumb_func
 549              	MX_DAC_Init:
 550              	.LFB46:
 646:Src/main.c    **** {
 551              		.loc 1 646 0
 552              		.cfi_startproc
 646:Src/main.c    **** {
 553              		.loc 1 646 0
 554 0000 00B5     		push	{lr}
 555              	.LCFI8:
 556              		.cfi_def_cfa_offset 4
 557              		.cfi_offset 14, -4
 558 0002 83B0     		sub	sp, sp, #12
 559              	.LCFI9:
 560              		.cfi_def_cfa_offset 16
 652:Src/main.c    ****   hdac.Instance = DAC;
 561              		.loc 1 652 0
 562 0004 0D48     		ldr	r0, .L35
 563 0006 0E4B     		ldr	r3, .L35+4
 564 0008 0360     		str	r3, [r0]
 653:Src/main.c    ****   if (HAL_DAC_Init(&hdac) != HAL_OK)
 565              		.loc 1 653 0
 566 000a FFF7FEFF 		bl	HAL_DAC_Init
 567              	.LVL28:
 568 000e 0028     		cmp	r0, #0
 569 0010 03D0     		beq	.L33
 655:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 570              		.loc 1 655 0
 571 0012 0C48     		ldr	r0, .L35+8
 572 0014 0C49     		ldr	r1, .L35+12
 573 0016 FFF7FEFF 		bl	_Error_Handler
 574              	.LVL29:
 575              	.L33:
 660:Src/main.c    ****   sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
 576              		.loc 1 660 0
 577 001a 0023     		mov	r3, #0
 578 001c 0093     		str	r3, [sp]
 661:Src/main.c    ****   sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
 579              		.loc 1 661 0
 580 001e 0193     		str	r3, [sp, #4]
 662:Src/main.c    ****   if (HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1) != HAL_OK)
 581              		.loc 1 662 0
 582 0020 0648     		ldr	r0, .L35
 583 0022 6946     		mov	r1, sp
 584 0024 0022     		mov	r2, #0
 585 0026 FFF7FEFF 		bl	HAL_DAC_ConfigChannel
ARM GAS  /tmp/cclyB5Uc.s 			page 45


 586              	.LVL30:
 587 002a 0028     		cmp	r0, #0
 588 002c 04D0     		beq	.L32
 664:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 589              		.loc 1 664 0
 590 002e 0548     		ldr	r0, .L35+8
 591 0030 A621     		mov	r1, #166
 592 0032 8900     		lsl	r1, r1, #2
 593 0034 FFF7FEFF 		bl	_Error_Handler
 594              	.LVL31:
 595              	.L32:
 667:Src/main.c    **** }
 596              		.loc 1 667 0
 597 0038 03B0     		add	sp, sp, #12
 598              		@ sp needed
 599 003a 00BD     		pop	{pc}
 600              	.L36:
 601              		.align	2
 602              	.L35:
 603 003c 00000000 		.word	hdac
 604 0040 00740040 		.word	1073771520
 605 0044 00000000 		.word	.LC9
 606 0048 8F020000 		.word	655
 607              		.cfi_endproc
 608              	.LFE46:
 610              		.section	.text.MX_TIM14_Init,"ax",%progbits
 611              		.align	2
 612              		.code	16
 613              		.thumb_func
 615              	MX_TIM14_Init:
 616              	.LFB41:
 515:Src/main.c    **** {
 617              		.loc 1 515 0
 618              		.cfi_startproc
 619 0000 08B5     		push	{r3, lr}
 620              	.LCFI10:
 621              		.cfi_def_cfa_offset 8
 622              		.cfi_offset 3, -8
 623              		.cfi_offset 14, -4
 516:Src/main.c    ****   htim14.Instance = TIM14;
 624              		.loc 1 516 0
 625 0002 0C48     		ldr	r0, .L39
 626 0004 0C4B     		ldr	r3, .L39+4
 627 0006 0360     		str	r3, [r0]
 517:Src/main.c    ****   htim14.Init.Prescaler = 11;
 628              		.loc 1 517 0
 629 0008 0B23     		mov	r3, #11
 630 000a 4360     		str	r3, [r0, #4]
 518:Src/main.c    ****   htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 631              		.loc 1 518 0
 632 000c 0023     		mov	r3, #0
 633 000e 8360     		str	r3, [r0, #8]
 519:Src/main.c    ****   htim14.Init.Period = 1000;
 634              		.loc 1 519 0
 635 0010 FA22     		mov	r2, #250
 636 0012 9200     		lsl	r2, r2, #2
 637 0014 C260     		str	r2, [r0, #12]
ARM GAS  /tmp/cclyB5Uc.s 			page 46


 520:Src/main.c    ****   htim14.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 638              		.loc 1 520 0
 639 0016 8022     		mov	r2, #128
 640 0018 9200     		lsl	r2, r2, #2
 641 001a 0261     		str	r2, [r0, #16]
 521:Src/main.c    ****   htim14.Init.RepetitionCounter = 0;
 642              		.loc 1 521 0
 643 001c 4361     		str	r3, [r0, #20]
 522:Src/main.c    ****   htim14.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 644              		.loc 1 522 0
 645 001e 8361     		str	r3, [r0, #24]
 523:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim14) != HAL_OK)
 646              		.loc 1 523 0
 647 0020 FFF7FEFF 		bl	HAL_TIM_Base_Init
 648              	.LVL32:
 649 0024 0028     		cmp	r0, #0
 650 0026 03D0     		beq	.L37
 525:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 651              		.loc 1 525 0
 652 0028 0448     		ldr	r0, .L39+8
 653 002a 0549     		ldr	r1, .L39+12
 654 002c FFF7FEFF 		bl	_Error_Handler
 655              	.LVL33:
 656              	.L37:
 527:Src/main.c    **** }
 657              		.loc 1 527 0
 658              		@ sp needed
 659 0030 08BD     		pop	{r3, pc}
 660              	.L40:
 661 0032 C046     		.align	2
 662              	.L39:
 663 0034 00000000 		.word	htim14
 664 0038 00200040 		.word	1073750016
 665 003c 00000000 		.word	.LC9
 666 0040 0D020000 		.word	525
 667              		.cfi_endproc
 668              	.LFE41:
 670              		.section	.text.MX_TIM15_Init,"ax",%progbits
 671              		.align	2
 672              		.code	16
 673              		.thumb_func
 675              	MX_TIM15_Init:
 676              	.LFB42:
 531:Src/main.c    **** {
 677              		.loc 1 531 0
 678              		.cfi_startproc
 679 0000 08B5     		push	{r3, lr}
 680              	.LCFI11:
 681              		.cfi_def_cfa_offset 8
 682              		.cfi_offset 3, -8
 683              		.cfi_offset 14, -4
 532:Src/main.c    ****   htim15.Instance = TIM15;
 684              		.loc 1 532 0
 685 0002 0C48     		ldr	r0, .L43
 686 0004 0C4B     		ldr	r3, .L43+4
 687 0006 0360     		str	r3, [r0]
 533:Src/main.c    ****   htim15.Init.Prescaler = 11;
ARM GAS  /tmp/cclyB5Uc.s 			page 47


 688              		.loc 1 533 0
 689 0008 0B23     		mov	r3, #11
 690 000a 4360     		str	r3, [r0, #4]
 534:Src/main.c    ****   htim15.Init.CounterMode = TIM_COUNTERMODE_UP;
 691              		.loc 1 534 0
 692 000c 0023     		mov	r3, #0
 693 000e 8360     		str	r3, [r0, #8]
 535:Src/main.c    ****   htim15.Init.Period = 1000;
 694              		.loc 1 535 0
 695 0010 FA22     		mov	r2, #250
 696 0012 9200     		lsl	r2, r2, #2
 697 0014 C260     		str	r2, [r0, #12]
 536:Src/main.c    ****   htim15.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 698              		.loc 1 536 0
 699 0016 8022     		mov	r2, #128
 700 0018 9200     		lsl	r2, r2, #2
 701 001a 0261     		str	r2, [r0, #16]
 537:Src/main.c    ****   htim15.Init.RepetitionCounter = 0;
 702              		.loc 1 537 0
 703 001c 4361     		str	r3, [r0, #20]
 538:Src/main.c    ****   htim15.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 704              		.loc 1 538 0
 705 001e 8361     		str	r3, [r0, #24]
 539:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim15) != HAL_OK)
 706              		.loc 1 539 0
 707 0020 FFF7FEFF 		bl	HAL_TIM_Base_Init
 708              	.LVL34:
 709 0024 0028     		cmp	r0, #0
 710 0026 03D0     		beq	.L41
 541:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 711              		.loc 1 541 0
 712 0028 0448     		ldr	r0, .L43+8
 713 002a 0549     		ldr	r1, .L43+12
 714 002c FFF7FEFF 		bl	_Error_Handler
 715              	.LVL35:
 716              	.L41:
 543:Src/main.c    **** }
 717              		.loc 1 543 0
 718              		@ sp needed
 719 0030 08BD     		pop	{r3, pc}
 720              	.L44:
 721 0032 C046     		.align	2
 722              	.L43:
 723 0034 00000000 		.word	htim15
 724 0038 00400140 		.word	1073823744
 725 003c 00000000 		.word	.LC9
 726 0040 1D020000 		.word	541
 727              		.cfi_endproc
 728              	.LFE42:
 730              		.section	.text.MX_ADC_Init,"ax",%progbits
 731              		.align	2
 732              		.code	16
 733              		.thumb_func
 735              	MX_ADC_Init:
 736              	.LFB39:
 443:Src/main.c    **** {
 737              		.loc 1 443 0
ARM GAS  /tmp/cclyB5Uc.s 			page 48


 738              		.cfi_startproc
 739 0000 00B5     		push	{lr}
 740              	.LCFI12:
 741              		.cfi_def_cfa_offset 4
 742              		.cfi_offset 14, -4
 743 0002 85B0     		sub	sp, sp, #20
 744              	.LCFI13:
 745              		.cfi_def_cfa_offset 24
 746              	.LBB29:
 444:Src/main.c    ****   __HAL_RCC_ADC1_CLK_ENABLE();
 747              		.loc 1 444 0
 748 0004 2A4B     		ldr	r3, .L50
 749 0006 9969     		ldr	r1, [r3, #24]
 750 0008 8022     		mov	r2, #128
 751 000a 9200     		lsl	r2, r2, #2
 752 000c 1143     		orr	r1, r2
 753 000e 9961     		str	r1, [r3, #24]
 754 0010 9B69     		ldr	r3, [r3, #24]
 755 0012 1A40     		and	r2, r3
 756 0014 0092     		str	r2, [sp]
 757 0016 009B     		ldr	r3, [sp]
 758              	.LBE29:
 449:Src/main.c    ****   hadc.Instance = ADC1;
 759              		.loc 1 449 0
 760 0018 2648     		ldr	r0, .L50+4
 761 001a 274B     		ldr	r3, .L50+8
 762 001c 0360     		str	r3, [r0]
 450:Src/main.c    ****   hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 763              		.loc 1 450 0
 764 001e 0023     		mov	r3, #0
 765 0020 4360     		str	r3, [r0, #4]
 451:Src/main.c    ****   hadc.Init.Resolution = ADC_RESOLUTION_12B;
 766              		.loc 1 451 0
 767 0022 8360     		str	r3, [r0, #8]
 452:Src/main.c    ****   hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 768              		.loc 1 452 0
 769 0024 C360     		str	r3, [r0, #12]
 453:Src/main.c    ****   hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 770              		.loc 1 453 0
 771 0026 0122     		mov	r2, #1
 772 0028 0261     		str	r2, [r0, #16]
 454:Src/main.c    ****   hadc.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 773              		.loc 1 454 0
 774 002a 0821     		mov	r1, #8
 775 002c 4161     		str	r1, [r0, #20]
 455:Src/main.c    ****   hadc.Init.LowPowerAutoWait = DISABLE;
 776              		.loc 1 455 0
 777 002e 8361     		str	r3, [r0, #24]
 456:Src/main.c    ****   hadc.Init.LowPowerAutoPowerOff = DISABLE;
 778              		.loc 1 456 0
 779 0030 C361     		str	r3, [r0, #28]
 457:Src/main.c    ****   hadc.Init.ContinuousConvMode = DISABLE;
 780              		.loc 1 457 0
 781 0032 0362     		str	r3, [r0, #32]
 458:Src/main.c    ****   hadc.Init.DiscontinuousConvMode = DISABLE;
 782              		.loc 1 458 0
 783 0034 4362     		str	r3, [r0, #36]
ARM GAS  /tmp/cclyB5Uc.s 			page 49


 459:Src/main.c    ****   hadc.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T1_TRGO;
 784              		.loc 1 459 0
 785 0036 8362     		str	r3, [r0, #40]
 460:Src/main.c    ****   hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 786              		.loc 1 460 0
 787 0038 8023     		mov	r3, #128
 788 003a DB00     		lsl	r3, r3, #3
 789 003c C362     		str	r3, [r0, #44]
 461:Src/main.c    ****   hadc.Init.DMAContinuousRequests = ENABLE;
 790              		.loc 1 461 0
 791 003e 0263     		str	r2, [r0, #48]
 462:Src/main.c    ****   hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 792              		.loc 1 462 0
 793 0040 4263     		str	r2, [r0, #52]
 463:Src/main.c    ****   if (HAL_ADC_Init(&hadc) != HAL_OK)
 794              		.loc 1 463 0
 795 0042 FFF7FEFF 		bl	HAL_ADC_Init
 796              	.LVL36:
 797 0046 0028     		cmp	r0, #0
 798 0048 04D0     		beq	.L46
 465:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 799              		.loc 1 465 0
 800 004a 1C48     		ldr	r0, .L50+12
 801 004c D221     		mov	r1, #210
 802 004e FF31     		add	r1, r1, #255
 803 0050 FFF7FEFF 		bl	_Error_Handler
 804              	.LVL37:
 805              	.L46:
 470:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_0;
 806              		.loc 1 470 0
 807 0054 0023     		mov	r3, #0
 808 0056 0193     		str	r3, [sp, #4]
 471:Src/main.c    ****   sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 809              		.loc 1 471 0
 810 0058 8023     		mov	r3, #128
 811 005a 5B01     		lsl	r3, r3, #5
 812 005c 0293     		str	r3, [sp, #8]
 472:Src/main.c    ****   sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES_5;
 813              		.loc 1 472 0
 814 005e 0323     		mov	r3, #3
 815 0060 0393     		str	r3, [sp, #12]
 473:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 816              		.loc 1 473 0
 817 0062 1448     		ldr	r0, .L50+4
 818 0064 01A9     		add	r1, sp, #4
 819 0066 FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 820              	.LVL38:
 821 006a 0028     		cmp	r0, #0
 822 006c 04D0     		beq	.L47
 475:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 823              		.loc 1 475 0
 824 006e 1348     		ldr	r0, .L50+12
 825 0070 DC21     		mov	r1, #220
 826 0072 FF31     		add	r1, r1, #255
 827 0074 FFF7FEFF 		bl	_Error_Handler
 828              	.LVL39:
 829              	.L47:
ARM GAS  /tmp/cclyB5Uc.s 			page 50


 480:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_1;
 830              		.loc 1 480 0
 831 0078 0123     		mov	r3, #1
 832 007a 0193     		str	r3, [sp, #4]
 481:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 833              		.loc 1 481 0
 834 007c 0D48     		ldr	r0, .L50+4
 835 007e 01A9     		add	r1, sp, #4
 836 0080 FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 837              	.LVL40:
 838 0084 0028     		cmp	r0, #0
 839 0086 04D0     		beq	.L48
 483:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 840              		.loc 1 483 0
 841 0088 0C48     		ldr	r0, .L50+12
 842 008a E421     		mov	r1, #228
 843 008c FF31     		add	r1, r1, #255
 844 008e FFF7FEFF 		bl	_Error_Handler
 845              	.LVL41:
 846              	.L48:
 488:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_2;
 847              		.loc 1 488 0
 848 0092 0223     		mov	r3, #2
 849 0094 0193     		str	r3, [sp, #4]
 489:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 850              		.loc 1 489 0
 851 0096 0748     		ldr	r0, .L50+4
 852 0098 01A9     		add	r1, sp, #4
 853 009a FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 854              	.LVL42:
 855 009e 0028     		cmp	r0, #0
 856 00a0 04D0     		beq	.L45
 491:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 857              		.loc 1 491 0
 858 00a2 0648     		ldr	r0, .L50+12
 859 00a4 EC21     		mov	r1, #236
 860 00a6 FF31     		add	r1, r1, #255
 861 00a8 FFF7FEFF 		bl	_Error_Handler
 862              	.LVL43:
 863              	.L45:
 495:Src/main.c    **** }
 864              		.loc 1 495 0
 865 00ac 05B0     		add	sp, sp, #20
 866              		@ sp needed
 867 00ae 00BD     		pop	{pc}
 868              	.L51:
 869              		.align	2
 870              	.L50:
 871 00b0 00100240 		.word	1073876992
 872 00b4 00000000 		.word	hadc
 873 00b8 00240140 		.word	1073816576
 874 00bc 00000000 		.word	.LC9
 875              		.cfi_endproc
 876              	.LFE39:
 878              		.section	.text.USER_TIM1_Init,"ax",%progbits
 879              		.align	2
 880              		.code	16
ARM GAS  /tmp/cclyB5Uc.s 			page 51


 881              		.thumb_func
 883              	USER_TIM1_Init:
 884              	.LFB45:
 590:Src/main.c    **** {
 885              		.loc 1 590 0
 886              		.cfi_startproc
 887 0000 00B5     		push	{lr}
 888              	.LCFI14:
 889              		.cfi_def_cfa_offset 4
 890              		.cfi_offset 14, -4
 891 0002 93B0     		sub	sp, sp, #76
 892              	.LCFI15:
 893              		.cfi_def_cfa_offset 80
 894              	.LBB30:
 591:Src/main.c    ****   __HAL_RCC_TIM1_CLK_ENABLE();
 895              		.loc 1 591 0
 896 0004 2D4B     		ldr	r3, .L57
 897 0006 9969     		ldr	r1, [r3, #24]
 898 0008 8022     		mov	r2, #128
 899 000a 1201     		lsl	r2, r2, #4
 900 000c 1143     		orr	r1, r2
 901 000e 9961     		str	r1, [r3, #24]
 902 0010 9B69     		ldr	r3, [r3, #24]
 903 0012 1A40     		and	r2, r3
 904 0014 0192     		str	r2, [sp, #4]
 905 0016 019B     		ldr	r3, [sp, #4]
 906              	.LBE30:
 597:Src/main.c    ****   htim1.Instance = TIM1;
 907              		.loc 1 597 0
 908 0018 2948     		ldr	r0, .L57+4
 909 001a 2A4B     		ldr	r3, .L57+8
 910 001c 0360     		str	r3, [r0]
 598:Src/main.c    ****   htim1.Init.Prescaler = 0;
 911              		.loc 1 598 0
 912 001e 0023     		mov	r3, #0
 913 0020 4360     		str	r3, [r0, #4]
 599:Src/main.c    ****   htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 914              		.loc 1 599 0
 915 0022 8360     		str	r3, [r0, #8]
 600:Src/main.c    ****   htim1.Init.Period = 1024;
 916              		.loc 1 600 0
 917 0024 8022     		mov	r2, #128
 918 0026 D200     		lsl	r2, r2, #3
 919 0028 C260     		str	r2, [r0, #12]
 601:Src/main.c    ****   htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;
 920              		.loc 1 601 0
 921 002a 8022     		mov	r2, #128
 922 002c 5200     		lsl	r2, r2, #1
 923 002e 0261     		str	r2, [r0, #16]
 602:Src/main.c    ****   htim1.Init.RepetitionCounter = 0;
 924              		.loc 1 602 0
 925 0030 4361     		str	r3, [r0, #20]
 603:Src/main.c    ****   htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 926              		.loc 1 603 0
 927 0032 8023     		mov	r3, #128
 928 0034 8361     		str	r3, [r0, #24]
 604:Src/main.c    ****   if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
ARM GAS  /tmp/cclyB5Uc.s 			page 52


 929              		.loc 1 604 0
 930 0036 FFF7FEFF 		bl	HAL_TIM_PWM_Init
 931              	.LVL44:
 932 003a 0028     		cmp	r0, #0
 933 003c 03D0     		beq	.L53
 606:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 934              		.loc 1 606 0
 935 003e 2248     		ldr	r0, .L57+12
 936 0040 2249     		ldr	r1, .L57+16
 937 0042 FFF7FEFF 		bl	_Error_Handler
 938              	.LVL45:
 939              	.L53:
 609:Src/main.c    ****   sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 940              		.loc 1 609 0
 941 0046 2023     		mov	r3, #32
 942 0048 1093     		str	r3, [sp, #64]
 610:Src/main.c    ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 943              		.loc 1 610 0
 944 004a 0023     		mov	r3, #0
 945 004c 1193     		str	r3, [sp, #68]
 611:Src/main.c    ****   if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 946              		.loc 1 611 0
 947 004e 1C48     		ldr	r0, .L57+4
 948 0050 10A9     		add	r1, sp, #64
 949 0052 FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 950              	.LVL46:
 951 0056 0028     		cmp	r0, #0
 952 0058 03D0     		beq	.L54
 613:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 953              		.loc 1 613 0
 954 005a 1B48     		ldr	r0, .L57+12
 955 005c 1C49     		ldr	r1, .L57+20
 956 005e FFF7FEFF 		bl	_Error_Handler
 957              	.LVL47:
 958              	.L54:
 616:Src/main.c    ****   sConfigOC.OCMode = TIM_OCMODE_PWM1;
 959              		.loc 1 616 0
 960 0062 6023     		mov	r3, #96
 961 0064 0993     		str	r3, [sp, #36]
 617:Src/main.c    ****   sConfigOC.Pulse = 0;
 962              		.loc 1 617 0
 963 0066 0023     		mov	r3, #0
 964 0068 0A93     		str	r3, [sp, #40]
 618:Src/main.c    ****   sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 965              		.loc 1 618 0
 966 006a 0B93     		str	r3, [sp, #44]
 619:Src/main.c    ****   sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 967              		.loc 1 619 0
 968 006c 0C93     		str	r3, [sp, #48]
 620:Src/main.c    ****   sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 969              		.loc 1 620 0
 970 006e 0D93     		str	r3, [sp, #52]
 621:Src/main.c    ****   sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 971              		.loc 1 621 0
 972 0070 0E93     		str	r3, [sp, #56]
 622:Src/main.c    ****   sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 973              		.loc 1 622 0
ARM GAS  /tmp/cclyB5Uc.s 			page 53


 974 0072 0F93     		str	r3, [sp, #60]
 623:Src/main.c    ****   if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 975              		.loc 1 623 0
 976 0074 1248     		ldr	r0, .L57+4
 977 0076 09A9     		add	r1, sp, #36
 978 0078 0022     		mov	r2, #0
 979 007a FFF7FEFF 		bl	HAL_TIM_PWM_ConfigChannel
 980              	.LVL48:
 981 007e 0028     		cmp	r0, #0
 982 0080 03D0     		beq	.L55
 625:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 983              		.loc 1 625 0
 984 0082 1148     		ldr	r0, .L57+12
 985 0084 1349     		ldr	r1, .L57+24
 986 0086 FFF7FEFF 		bl	_Error_Handler
 987              	.LVL49:
 988              	.L55:
 628:Src/main.c    ****   sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 989              		.loc 1 628 0
 990 008a 0023     		mov	r3, #0
 991 008c 0293     		str	r3, [sp, #8]
 629:Src/main.c    ****   sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 992              		.loc 1 629 0
 993 008e 0393     		str	r3, [sp, #12]
 630:Src/main.c    ****   sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 994              		.loc 1 630 0
 995 0090 0493     		str	r3, [sp, #16]
 631:Src/main.c    ****   sBreakDeadTimeConfig.DeadTime = 0;
 996              		.loc 1 631 0
 997 0092 0593     		str	r3, [sp, #20]
 632:Src/main.c    ****   sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 998              		.loc 1 632 0
 999 0094 0693     		str	r3, [sp, #24]
 633:Src/main.c    ****   sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 1000              		.loc 1 633 0
 1001 0096 8022     		mov	r2, #128
 1002 0098 9201     		lsl	r2, r2, #6
 1003 009a 0792     		str	r2, [sp, #28]
 634:Src/main.c    ****   sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 1004              		.loc 1 634 0
 1005 009c 0893     		str	r3, [sp, #32]
 635:Src/main.c    ****   if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 1006              		.loc 1 635 0
 1007 009e 0848     		ldr	r0, .L57+4
 1008 00a0 02A9     		add	r1, sp, #8
 1009 00a2 FFF7FEFF 		bl	HAL_TIMEx_ConfigBreakDeadTime
 1010              	.LVL50:
 1011 00a6 0028     		cmp	r0, #0
 1012 00a8 03D0     		beq	.L56
 637:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 1013              		.loc 1 637 0
 1014 00aa 0748     		ldr	r0, .L57+12
 1015 00ac 0A49     		ldr	r1, .L57+28
 1016 00ae FFF7FEFF 		bl	_Error_Handler
 1017              	.LVL51:
 1018              	.L56:
 640:Src/main.c    ****   HAL_TIM_MspPostInit(&htim1);
ARM GAS  /tmp/cclyB5Uc.s 			page 54


 1019              		.loc 1 640 0
 1020 00b2 0348     		ldr	r0, .L57+4
 1021 00b4 FFF7FEFF 		bl	HAL_TIM_MspPostInit
 1022              	.LVL52:
 641:Src/main.c    **** }
 1023              		.loc 1 641 0
 1024 00b8 13B0     		add	sp, sp, #76
 1025              		@ sp needed
 1026 00ba 00BD     		pop	{pc}
 1027              	.L58:
 1028              		.align	2
 1029              	.L57:
 1030 00bc 00100240 		.word	1073876992
 1031 00c0 00000000 		.word	htim1
 1032 00c4 002C0140 		.word	1073818624
 1033 00c8 00000000 		.word	.LC9
 1034 00cc 5E020000 		.word	606
 1035 00d0 65020000 		.word	613
 1036 00d4 71020000 		.word	625
 1037 00d8 7D020000 		.word	637
 1038              		.cfi_endproc
 1039              	.LFE45:
 1041              		.section	.text.MX_TIM17_Init,"ax",%progbits
 1042              		.align	2
 1043              		.code	16
 1044              		.thumb_func
 1046              	MX_TIM17_Init:
 1047              	.LFB43:
 547:Src/main.c    **** {
 1048              		.loc 1 547 0
 1049              		.cfi_startproc
 1050 0000 08B5     		push	{r3, lr}
 1051              	.LCFI16:
 1052              		.cfi_def_cfa_offset 8
 1053              		.cfi_offset 3, -8
 1054              		.cfi_offset 14, -4
 548:Src/main.c    ****   htim17.Instance = TIM17;
 1055              		.loc 1 548 0
 1056 0002 0C48     		ldr	r0, .L61
 1057 0004 0C4B     		ldr	r3, .L61+4
 1058 0006 0360     		str	r3, [r0]
 549:Src/main.c    ****   htim17.Init.Prescaler = 11;
 1059              		.loc 1 549 0
 1060 0008 0B23     		mov	r3, #11
 1061 000a 4360     		str	r3, [r0, #4]
 550:Src/main.c    ****   htim17.Init.CounterMode = TIM_COUNTERMODE_UP;
 1062              		.loc 1 550 0
 1063 000c 0023     		mov	r3, #0
 1064 000e 8360     		str	r3, [r0, #8]
 551:Src/main.c    ****   htim17.Init.Period = 1000;
 1065              		.loc 1 551 0
 1066 0010 FA22     		mov	r2, #250
 1067 0012 9200     		lsl	r2, r2, #2
 1068 0014 C260     		str	r2, [r0, #12]
 552:Src/main.c    ****   htim17.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 1069              		.loc 1 552 0
 1070 0016 8022     		mov	r2, #128
ARM GAS  /tmp/cclyB5Uc.s 			page 55


 1071 0018 9200     		lsl	r2, r2, #2
 1072 001a 0261     		str	r2, [r0, #16]
 553:Src/main.c    ****   htim17.Init.RepetitionCounter = 0;
 1073              		.loc 1 553 0
 1074 001c 4361     		str	r3, [r0, #20]
 554:Src/main.c    ****   htim17.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 1075              		.loc 1 554 0
 1076 001e 8023     		mov	r3, #128
 1077 0020 8361     		str	r3, [r0, #24]
 555:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim17) != HAL_OK)
 1078              		.loc 1 555 0
 1079 0022 FFF7FEFF 		bl	HAL_TIM_Base_Init
 1080              	.LVL53:
 1081 0026 0028     		cmp	r0, #0
 1082 0028 03D0     		beq	.L59
 557:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 1083              		.loc 1 557 0
 1084 002a 0448     		ldr	r0, .L61+8
 1085 002c 0449     		ldr	r1, .L61+12
 1086 002e FFF7FEFF 		bl	_Error_Handler
 1087              	.LVL54:
 1088              	.L59:
 559:Src/main.c    **** }
 1089              		.loc 1 559 0
 1090              		@ sp needed
 1091 0032 08BD     		pop	{r3, pc}
 1092              	.L62:
 1093              		.align	2
 1094              	.L61:
 1095 0034 00000000 		.word	htim17
 1096 0038 00480140 		.word	1073825792
 1097 003c 00000000 		.word	.LC9
 1098 0040 2D020000 		.word	557
 1099              		.cfi_endproc
 1100              	.LFE43:
 1102              		.section	.text.SystemClock_Config,"ax",%progbits
 1103              		.align	2
 1104              		.global	SystemClock_Config
 1105              		.code	16
 1106              		.thumb_func
 1108              	SystemClock_Config:
 1109              	.LFB38:
 390:Src/main.c    **** {
 1110              		.loc 1 390 0
 1111              		.cfi_startproc
 1112 0000 00B5     		push	{lr}
 1113              	.LCFI17:
 1114              		.cfi_def_cfa_offset 4
 1115              		.cfi_offset 14, -4
 1116 0002 99B0     		sub	sp, sp, #100
 1117              	.LCFI18:
 1118              		.cfi_def_cfa_offset 104
 398:Src/main.c    ****   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI14|RCC_OSCILLATORTYPE_HSI48;
 1119              		.loc 1 398 0
 1120 0004 3023     		mov	r3, #48
 1121 0006 0B93     		str	r3, [sp, #44]
 399:Src/main.c    ****   RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
ARM GAS  /tmp/cclyB5Uc.s 			page 56


 1122              		.loc 1 399 0
 1123 0008 0123     		mov	r3, #1
 1124 000a 1393     		str	r3, [sp, #76]
 400:Src/main.c    ****   RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
 1125              		.loc 1 400 0
 1126 000c 1093     		str	r3, [sp, #64]
 401:Src/main.c    ****   RCC_OscInitStruct.HSI14CalibrationValue = 16;
 1127              		.loc 1 401 0
 1128 000e 1023     		mov	r3, #16
 1129 0010 1193     		str	r3, [sp, #68]
 402:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 1130              		.loc 1 402 0
 1131 0012 0023     		mov	r3, #0
 1132 0014 1493     		str	r3, [sp, #80]
 403:Src/main.c    ****   if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 1133              		.loc 1 403 0
 1134 0016 0BA8     		add	r0, sp, #44
 1135 0018 FFF7FEFF 		bl	HAL_RCC_OscConfig
 1136              	.LVL55:
 1137 001c 0028     		cmp	r0, #0
 1138 001e 04D0     		beq	.L64
 405:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 1139              		.loc 1 405 0
 1140 0020 1C48     		ldr	r0, .L67
 1141 0022 9621     		mov	r1, #150
 1142 0024 FF31     		add	r1, r1, #255
 1143 0026 FFF7FEFF 		bl	_Error_Handler
 1144              	.LVL56:
 1145              	.L64:
 410:Src/main.c    ****   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 1146              		.loc 1 410 0
 1147 002a 0723     		mov	r3, #7
 1148 002c 0793     		str	r3, [sp, #28]
 412:Src/main.c    ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
 1149              		.loc 1 412 0
 1150 002e 0323     		mov	r3, #3
 1151 0030 0893     		str	r3, [sp, #32]
 413:Src/main.c    ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 1152              		.loc 1 413 0
 1153 0032 0023     		mov	r3, #0
 1154 0034 0993     		str	r3, [sp, #36]
 414:Src/main.c    ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 1155              		.loc 1 414 0
 1156 0036 0A93     		str	r3, [sp, #40]
 416:Src/main.c    ****   if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 1157              		.loc 1 416 0
 1158 0038 07A8     		add	r0, sp, #28
 1159 003a 0121     		mov	r1, #1
 1160 003c FFF7FEFF 		bl	HAL_RCC_ClockConfig
 1161              	.LVL57:
 1162 0040 0028     		cmp	r0, #0
 1163 0042 04D0     		beq	.L65
 418:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 1164              		.loc 1 418 0
 1165 0044 1348     		ldr	r0, .L67
 1166 0046 D121     		mov	r1, #209
 1167 0048 4900     		lsl	r1, r1, #1
ARM GAS  /tmp/cclyB5Uc.s 			page 57


 1168 004a FFF7FEFF 		bl	_Error_Handler
 1169              	.LVL58:
 1170              	.L65:
 421:Src/main.c    ****   PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 1171              		.loc 1 421 0
 1172 004e 8023     		mov	r3, #128
 1173 0050 9B02     		lsl	r3, r3, #10
 1174 0052 0093     		str	r3, [sp]
 422:Src/main.c    ****   PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
 1175              		.loc 1 422 0
 1176 0054 0023     		mov	r3, #0
 1177 0056 0693     		str	r3, [sp, #24]
 424:Src/main.c    ****   if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 1178              		.loc 1 424 0
 1179 0058 6846     		mov	r0, sp
 1180 005a FFF7FEFF 		bl	HAL_RCCEx_PeriphCLKConfig
 1181              	.LVL59:
 1182 005e 0028     		cmp	r0, #0
 1183 0060 04D0     		beq	.L66
 426:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 1184              		.loc 1 426 0
 1185 0062 0C48     		ldr	r0, .L67
 1186 0064 D521     		mov	r1, #213
 1187 0066 4900     		lsl	r1, r1, #1
 1188 0068 FFF7FEFF 		bl	_Error_Handler
 1189              	.LVL60:
 1190              	.L66:
 431:Src/main.c    ****   HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 1191              		.loc 1 431 0
 1192 006c FFF7FEFF 		bl	HAL_RCC_GetHCLKFreq
 1193              	.LVL61:
 1194 0070 FA21     		mov	r1, #250
 1195 0072 8900     		lsl	r1, r1, #2
 1196 0074 FFF7FEFF 		bl	__aeabi_uidiv
 1197              	.LVL62:
 1198 0078 FFF7FEFF 		bl	HAL_SYSTICK_Config
 1199              	.LVL63:
 435:Src/main.c    ****   HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 1200              		.loc 1 435 0
 1201 007c 0420     		mov	r0, #4
 1202 007e FFF7FEFF 		bl	HAL_SYSTICK_CLKSourceConfig
 1203              	.LVL64:
 438:Src/main.c    ****   HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 1204              		.loc 1 438 0
 1205 0082 0120     		mov	r0, #1
 1206 0084 4042     		neg	r0, r0
 1207 0086 0021     		mov	r1, #0
 1208 0088 0022     		mov	r2, #0
 1209 008a FFF7FEFF 		bl	HAL_NVIC_SetPriority
 1210              	.LVL65:
 439:Src/main.c    **** }
 1211              		.loc 1 439 0
 1212 008e 19B0     		add	sp, sp, #100
 1213              		@ sp needed
 1214 0090 00BD     		pop	{pc}
 1215              	.L68:
 1216 0092 C046     		.align	2
ARM GAS  /tmp/cclyB5Uc.s 			page 58


 1217              	.L67:
 1218 0094 00000000 		.word	.LC9
 1219              		.cfi_endproc
 1220              	.LFE38:
 1222              		.global	__aeabi_i2d
 1223              		.global	__aeabi_ddiv
 1224              		.global	__aeabi_dmul
 1225              		.global	__aeabi_d2uiz
 1226              		.section	.text.main,"ax",%progbits
 1227              		.align	2
 1228              		.global	main
 1229              		.code	16
 1230              		.thumb_func
 1232              	main:
 1233              	.LFB37:
 173:Src/main.c    **** {
 1234              		.loc 1 173 0
 1235              		.cfi_startproc
 1236 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1237              	.LCFI19:
 1238              		.cfi_def_cfa_offset 20
 1239              		.cfi_offset 4, -20
 1240              		.cfi_offset 5, -16
 1241              		.cfi_offset 6, -12
 1242              		.cfi_offset 7, -8
 1243              		.cfi_offset 14, -4
 1244 0002 5746     		mov	r7, r10
 1245 0004 4646     		mov	r6, r8
 1246 0006 C0B4     		push	{r6, r7}
 1247              	.LCFI20:
 1248              		.cfi_def_cfa_offset 28
 1249              		.cfi_offset 8, -28
 1250              		.cfi_offset 10, -24
 1251 0008 83B0     		sub	sp, sp, #12
 1252              	.LCFI21:
 1253              		.cfi_def_cfa_offset 40
 181:Src/main.c    ****   HAL_Init();
 1254              		.loc 1 181 0
 1255 000a FFF7FEFF 		bl	HAL_Init
 1256              	.LVL66:
 188:Src/main.c    ****   SystemClock_Config();
 1257              		.loc 1 188 0
 1258 000e FFF7FEFF 		bl	SystemClock_Config
 1259              	.LVL67:
 195:Src/main.c    ****   MX_GPIO_Init();
 1260              		.loc 1 195 0
 1261 0012 FFF7FEFF 		bl	MX_GPIO_Init
 1262              	.LVL68:
 196:Src/main.c    ****   HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1263              		.loc 1 196 0
 1264 0016 9024     		mov	r4, #144
 1265 0018 E405     		lsl	r4, r4, #23
 1266 001a 201C     		mov	r0, r4
 1267 001c 8021     		mov	r1, #128
 1268 001e 0902     		lsl	r1, r1, #8
 1269 0020 0122     		mov	r2, #1
 1270 0022 FFF7FEFF 		bl	HAL_GPIO_WritePin
ARM GAS  /tmp/cclyB5Uc.s 			page 59


 1271              	.LVL69:
 197:Src/main.c    ****   HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, SET);
 1272              		.loc 1 197 0
 1273 0026 201C     		mov	r0, r4
 1274 0028 8021     		mov	r1, #128
 1275 002a C900     		lsl	r1, r1, #3
 1276 002c 0122     		mov	r2, #1
 1277 002e FFF7FEFF 		bl	HAL_GPIO_WritePin
 1278              	.LVL70:
 199:Src/main.c    **** 	MX_DAC_Init();
 1279              		.loc 1 199 0
 1280 0032 FFF7FEFF 		bl	MX_DAC_Init
 1281              	.LVL71:
 201:Src/main.c    **** 	HAL_DAC_Start(&hdac, DAC_CHANNEL_1);
 1282              		.loc 1 201 0
 1283 0036 BC4C     		ldr	r4, .L98+8
 1284 0038 201C     		mov	r0, r4
 1285 003a 0021     		mov	r1, #0
 1286 003c FFF7FEFF 		bl	HAL_DAC_Start
 1287              	.LVL72:
 202:Src/main.c    **** 	HAL_DAC_SetValue(&hdac, DAC_CHANNEL_1, DAC_ALIGN_12B_R, 2048);
 1288              		.loc 1 202 0
 1289 0040 201C     		mov	r0, r4
 1290 0042 0021     		mov	r1, #0
 1291 0044 0022     		mov	r2, #0
 1292 0046 8023     		mov	r3, #128
 1293 0048 1B01     		lsl	r3, r3, #4
 1294 004a FFF7FEFF 		bl	HAL_DAC_SetValue
 1295              	.LVL73:
 204:Src/main.c    **** 	MX_TIM14_Init();
 1296              		.loc 1 204 0
 1297 004e FFF7FEFF 		bl	MX_TIM14_Init
 1298              	.LVL74:
 205:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim14);
 1299              		.loc 1 205 0
 1300 0052 B648     		ldr	r0, .L98+12
 1301 0054 FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 1302              	.LVL75:
 206:Src/main.c    **** 	TIM14->CR1 &= ~(1UL);
 1303              		.loc 1 206 0
 1304 0058 B54B     		ldr	r3, .L98+16
 1305 005a 1A68     		ldr	r2, [r3]
 1306 005c 0124     		mov	r4, #1
 1307 005e A243     		bic	r2, r4
 1308 0060 1A60     		str	r2, [r3]
 208:Src/main.c    **** 	MX_TIM15_Init();
 1309              		.loc 1 208 0
 1310 0062 FFF7FEFF 		bl	MX_TIM15_Init
 1311              	.LVL76:
 209:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim15);
 1312              		.loc 1 209 0
 1313 0066 B348     		ldr	r0, .L98+20
 1314 0068 FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 1315              	.LVL77:
 210:Src/main.c    **** 	TIM15->CR1 &= ~(1UL);
 1316              		.loc 1 210 0
 1317 006c B24B     		ldr	r3, .L98+24
ARM GAS  /tmp/cclyB5Uc.s 			page 60


 1318 006e 1A68     		ldr	r2, [r3]
 1319 0070 A243     		bic	r2, r4
 1320 0072 1A60     		str	r2, [r3]
 212:Src/main.c    ****   MX_DMA_Init();
 1321              		.loc 1 212 0
 1322 0074 FFF7FEFF 		bl	MX_DMA_Init
 1323              	.LVL78:
 213:Src/main.c    ****   MX_ADC_Init();
 1324              		.loc 1 213 0
 1325 0078 FFF7FEFF 		bl	MX_ADC_Init
 1326              	.LVL79:
 215:Src/main.c    ****   HAL_ADC_Start_DMA(&hadc, (uint32_t*)adcBuffer, 3);
 1327              		.loc 1 215 0
 1328 007c AF48     		ldr	r0, .L98+28
 1329 007e B049     		ldr	r1, .L98+32
 1330 0080 0322     		mov	r2, #3
 1331 0082 FFF7FEFF 		bl	HAL_ADC_Start_DMA
 1332              	.LVL80:
 218:Src/main.c    **** 	USER_TIM1_Init();
 1333              		.loc 1 218 0
 1334 0086 FFF7FEFF 		bl	USER_TIM1_Init
 1335              	.LVL81:
 221:Src/main.c    ****   HAL_TIM_PWM_Start_IT(&htim1, TIM_CHANNEL_1);
 1336              		.loc 1 221 0
 1337 008a AE48     		ldr	r0, .L98+36
 1338 008c 0021     		mov	r1, #0
 1339 008e FFF7FEFF 		bl	HAL_TIM_PWM_Start_IT
 1340              	.LVL82:
 225:Src/main.c    ****   USER_TIM2_Init();
 1341              		.loc 1 225 0
 1342 0092 FFF7FEFF 		bl	USER_TIM2_Init
 1343              	.LVL83:
 227:Src/main.c    **** 	HAL_TIM_Base_Start(&htim2);
 1344              		.loc 1 227 0
 1345 0096 AC4C     		ldr	r4, .L98+40
 1346 0098 201C     		mov	r0, r4
 1347 009a FFF7FEFF 		bl	HAL_TIM_Base_Start
 1348              	.LVL84:
 228:Src/main.c    **** 	HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_2);
 1349              		.loc 1 228 0
 1350 009e 201C     		mov	r0, r4
 1351 00a0 0421     		mov	r1, #4
 1352 00a2 FFF7FEFF 		bl	HAL_TIM_OnePulse_Start
 1353              	.LVL85:
 233:Src/main.c    ****   MX_USB_MIDI_INIT();
 1354              		.loc 1 233 0
 1355 00a6 FFF7FEFF 		bl	MX_USB_MIDI_INIT
 1356              	.LVL86:
 238:Src/main.c    ****   if(FUNC_ERROR == midiInit() ){
 1357              		.loc 1 238 0
 1358 00aa FFF7FEFF 		bl	midiInit
 1359              	.LVL87:
 1360 00ae 0028     		cmp	r0, #0
 1361 00b0 16D1     		bne	.L70
 240:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1362              		.loc 1 240 0 discriminator 1
 1363 00b2 9026     		mov	r6, #144
ARM GAS  /tmp/cclyB5Uc.s 			page 61


 1364 00b4 F605     		lsl	r6, r6, #23
 1365 00b6 8025     		mov	r5, #128
 1366 00b8 2D02     		lsl	r5, r5, #8
 241:Src/main.c    **** 		  HAL_Delay(500);
 1367              		.loc 1 241 0 discriminator 1
 1368 00ba FA24     		mov	r4, #250
 1369 00bc 6400     		lsl	r4, r4, #1
 1370              	.L95:
 240:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1371              		.loc 1 240 0 discriminator 1
 1372 00be 301C     		mov	r0, r6
 1373 00c0 291C     		mov	r1, r5
 1374 00c2 0122     		mov	r2, #1
 1375 00c4 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1376              	.LVL88:
 241:Src/main.c    **** 		  HAL_Delay(500);
 1377              		.loc 1 241 0 discriminator 1
 1378 00c8 201C     		mov	r0, r4
 1379 00ca FFF7FEFF 		bl	HAL_Delay
 1380              	.LVL89:
 242:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 1381              		.loc 1 242 0 discriminator 1
 1382 00ce 301C     		mov	r0, r6
 1383 00d0 291C     		mov	r1, r5
 1384 00d2 0022     		mov	r2, #0
 1385 00d4 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1386              	.LVL90:
 243:Src/main.c    **** 		  HAL_Delay(500);
 1387              		.loc 1 243 0 discriminator 1
 1388 00d8 201C     		mov	r0, r4
 1389 00da FFF7FEFF 		bl	HAL_Delay
 1390              	.LVL91:
 1391 00de EEE7     		b	.L95
 1392              	.L70:
 249:Src/main.c    **** 	  if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 1393              		.loc 1 249 0
 1394 00e0 9A4E     		ldr	r6, .L98+44
 1395 00e2 FE25     		mov	r5, #254
 1396 00e4 6D00     		lsl	r5, r5, #1
 253:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 1397              		.loc 1 253 0
 1398 00e6 9024     		mov	r4, #144
 1399 00e8 E405     		lsl	r4, r4, #23
 1400              	.L96:
 249:Src/main.c    **** 	  if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 1401              		.loc 1 249 0
 1402 00ea 735D     		ldrb	r3, [r6, r5]
 1403 00ec 032B     		cmp	r3, #3
 1404 00ee 06D0     		beq	.L72
 253:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 1405              		.loc 1 253 0
 1406 00f0 201C     		mov	r0, r4
 1407 00f2 8021     		mov	r1, #128
 1408 00f4 0902     		lsl	r1, r1, #8
 1409 00f6 0022     		mov	r2, #0
 1410 00f8 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1411              	.LVL92:
ARM GAS  /tmp/cclyB5Uc.s 			page 62


 255:Src/main.c    ****   }
 1412              		.loc 1 255 0
 1413 00fc F5E7     		b	.L96
 1414              	.L72:
 257:Src/main.c    ****   MX_TIM17_Init();
 1415              		.loc 1 257 0
 1416 00fe FFF7FEFF 		bl	MX_TIM17_Init
 1417              	.LVL93:
 258:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim17);
 1418              		.loc 1 258 0
 1419 0102 9348     		ldr	r0, .L98+48
 1420 0104 FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 1421              	.LVL94:
 1422              	.LBB31:
 260:Src/main.c    ****   for (uint32_t i = 0; i < Vmax; i+=100) {
 1423              		.loc 1 260 0
 1424 0108 0024     		mov	r4, #0
 1425 010a 924E     		ldr	r6, .L98+52
 261:Src/main.c    ****     Vset = i;
 1426              		.loc 1 261 0
 1427 010c 924D     		ldr	r5, .L98+56
 260:Src/main.c    ****   for (uint32_t i = 0; i < Vmax; i+=100) {
 1428              		.loc 1 260 0
 1429 010e 04E0     		b	.L73
 1430              	.LVL95:
 1431              	.L74:
 261:Src/main.c    ****     Vset = i;
 1432              		.loc 1 261 0 discriminator 2
 1433 0110 2C60     		str	r4, [r5]
 262:Src/main.c    ****     HAL_Delay(3);
 1434              		.loc 1 262 0 discriminator 2
 1435 0112 0320     		mov	r0, #3
 1436 0114 FFF7FEFF 		bl	HAL_Delay
 1437              	.LVL96:
 260:Src/main.c    ****   for (uint32_t i = 0; i < Vmax; i+=100) {
 1438              		.loc 1 260 0 discriminator 2
 1439 0118 6434     		add	r4, r4, #100
 1440              	.LVL97:
 1441              	.L73:
 260:Src/main.c    ****   for (uint32_t i = 0; i < Vmax; i+=100) {
 1442              		.loc 1 260 0 is_stmt 0 discriminator 1
 1443 011a 3168     		ldr	r1, [r6]
 1444 011c 8C42     		cmp	r4, r1
 1445 011e F7D3     		bcc	.L74
 1446              	.LBE31:
 265:Src/main.c    ****   HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 1447              		.loc 1 265 0 is_stmt 1
 1448 0120 9020     		mov	r0, #144
 1449 0122 C005     		lsl	r0, r0, #23
 1450 0124 8021     		mov	r1, #128
 1451 0126 C900     		lsl	r1, r1, #3
 1452 0128 0022     		mov	r2, #0
 1453 012a FFF7FEFF 		bl	HAL_GPIO_WritePin
 1454              	.LVL98:
 267:Src/main.c    ****   Vset = Vmax;
 1455              		.loc 1 267 0
 1456 012e 894B     		ldr	r3, .L98+52
ARM GAS  /tmp/cclyB5Uc.s 			page 63


 1457 0130 1A68     		ldr	r2, [r3]
 1458 0132 894B     		ldr	r3, .L98+56
 1459 0134 1A60     		str	r2, [r3]
 1460              	.LBB32:
 369:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 1461              		.loc 1 369 0
 1462 0136 7B4D     		ldr	r5, .L98+4
 1463 0138 794C     		ldr	r4, .L98
 1464              	.LVL99:
 1465              	.LBE32:
 319:Src/main.c    **** 			curPeriode1 = (uint32_t)1000000 / (uint32_t)(curTone1);
 1466              		.loc 1 319 0
 1467 013a 884A     		ldr	r2, .L98+60
 1468 013c 9046     		mov	r8, r2
 1469 013e 0094     		str	r4, [sp]
 1470 0140 0195     		str	r5, [sp, #4]
 1471              	.L94:
 274:Src/main.c    **** 			if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 1472              		.loc 1 274 0
 1473 0142 FE23     		mov	r3, #254
 1474 0144 5B00     		lsl	r3, r3, #1
 1475 0146 814A     		ldr	r2, .L98+44
 1476 0148 D35C     		ldrb	r3, [r2, r3]
 1477 014a 032B     		cmp	r3, #3
 1478 014c 0ED1     		bne	.L76
 275:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1479              		.loc 1 275 0
 1480 014e 9026     		mov	r6, #144
 1481 0150 F605     		lsl	r6, r6, #23
 1482 0152 301C     		mov	r0, r6
 1483 0154 8021     		mov	r1, #128
 1484 0156 0902     		lsl	r1, r1, #8
 1485 0158 0122     		mov	r2, #1
 1486 015a FFF7FEFF 		bl	HAL_GPIO_WritePin
 1487              	.LVL100:
 284:Src/main.c    ****     if (HAL_GPIO_ReadPin(BUTTON_GPIO, BUTTON_PIN)) {
 1488              		.loc 1 284 0
 1489 015e 301C     		mov	r0, r6
 1490 0160 8021     		mov	r1, #128
 1491 0162 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 1492              	.LVL101:
 1493 0166 0028     		cmp	r0, #0
 1494 0168 17D0     		beq	.L97
 1495 016a 14E0     		b	.L77
 1496              	.L76:
 278:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1497              		.loc 1 278 0
 1498 016c 9027     		mov	r7, #144
 1499 016e FF05     		lsl	r7, r7, #23
 1500 0170 8026     		mov	r6, #128
 1501 0172 3602     		lsl	r6, r6, #8
 1502 0174 381C     		mov	r0, r7
 1503 0176 311C     		mov	r1, r6
 1504 0178 0122     		mov	r2, #1
 1505 017a FFF7FEFF 		bl	HAL_GPIO_WritePin
 1506              	.LVL102:
 279:Src/main.c    **** 			  HAL_Delay(200);
ARM GAS  /tmp/cclyB5Uc.s 			page 64


 1507              		.loc 1 279 0
 1508 017e C820     		mov	r0, #200
 1509 0180 FFF7FEFF 		bl	HAL_Delay
 1510              	.LVL103:
 280:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 1511              		.loc 1 280 0
 1512 0184 381C     		mov	r0, r7
 1513 0186 311C     		mov	r1, r6
 1514 0188 0022     		mov	r2, #0
 1515 018a FFF7FEFF 		bl	HAL_GPIO_WritePin
 1516              	.LVL104:
 281:Src/main.c    **** 			  HAL_Delay(200);
 1517              		.loc 1 281 0
 1518 018e C820     		mov	r0, #200
 1519 0190 FFF7FEFF 		bl	HAL_Delay
 1520              	.LVL105:
 283:Src/main.c    **** 	  }
 1521              		.loc 1 283 0
 1522 0194 D5E7     		b	.L94
 1523              	.L77:
 285:Src/main.c    ****       dfu_otter_bootloader();
 1524              		.loc 1 285 0
 1525 0196 FFF7FEFF 		bl	dfu_otter_bootloader
 1526              	.LVL106:
 1527              	.L97:
 289:Src/main.c    **** 		curTone0 = 0;
 1528              		.loc 1 289 0
 1529 019a 0023     		mov	r3, #0
 1530 019c 704A     		ldr	r2, .L98+64
 1531 019e 1380     		strh	r3, [r2]
 290:Src/main.c    **** 		curTone1 = 0;
 1532              		.loc 1 290 0
 1533 01a0 704A     		ldr	r2, .L98+68
 1534 01a2 1380     		strh	r3, [r2]
 1535              	.LVL107:
 1536              	.LBB33:
 293:Src/main.c    **** 	      if( freqs[i] > curTone0 ) {
 1537              		.loc 1 293 0
 1538 01a4 704E     		ldr	r6, .L98+72
 1539 01a6 6E48     		ldr	r0, .L98+64
 297:Src/main.c    **** 	      else if( freqs[i] > curTone1 ) {
 1540              		.loc 1 297 0
 1541 01a8 9246     		mov	r10, r2
 294:Src/main.c    **** 	          curTone1 = curTone0;
 1542              		.loc 1 294 0
 1543 01aa 151C     		mov	r5, r2
 295:Src/main.c    **** 	          curTone0 = freqs[i];
 1544              		.loc 1 295 0
 1545 01ac 071C     		mov	r7, r0
 292:Src/main.c    **** 	  for( int i = 0; i < 16; i++ ) { // find max pitch from all channels
 1546              		.loc 1 292 0
 1547 01ae 0EE0     		b	.L80
 1548              	.LVL108:
 1549              	.L83:
 293:Src/main.c    **** 	      if( freqs[i] > curTone0 ) {
 1550              		.loc 1 293 0
 1551 01b0 5A00     		lsl	r2, r3, #1
ARM GAS  /tmp/cclyB5Uc.s 			page 65


 1552 01b2 925B     		ldrh	r2, [r2, r6]
 1553 01b4 0188     		ldrh	r1, [r0]
 1554 01b6 8A42     		cmp	r2, r1
 1555 01b8 02D9     		bls	.L81
 294:Src/main.c    **** 	          curTone1 = curTone0;
 1556              		.loc 1 294 0
 1557 01ba 2980     		strh	r1, [r5]
 295:Src/main.c    **** 	          curTone0 = freqs[i];
 1558              		.loc 1 295 0
 1559 01bc 3A80     		strh	r2, [r7]
 1560 01be 05E0     		b	.L82
 1561              	.L81:
 297:Src/main.c    **** 	      else if( freqs[i] > curTone1 ) {
 1562              		.loc 1 297 0
 1563 01c0 5446     		mov	r4, r10
 1564 01c2 2188     		ldrh	r1, [r4]
 1565 01c4 8A42     		cmp	r2, r1
 1566 01c6 01D9     		bls	.L82
 298:Src/main.c    **** 	          curTone1 = freqs[i];
 1567              		.loc 1 298 0
 1568 01c8 6649     		ldr	r1, .L98+68
 1569 01ca 0A80     		strh	r2, [r1]
 1570              	.L82:
 292:Src/main.c    **** 	  for( int i = 0; i < 16; i++ ) { // find max pitch from all channels
 1571              		.loc 1 292 0
 1572 01cc 0133     		add	r3, r3, #1
 1573              	.LVL109:
 1574              	.L80:
 292:Src/main.c    **** 	  for( int i = 0; i < 16; i++ ) { // find max pitch from all channels
 1575              		.loc 1 292 0 is_stmt 0 discriminator 1
 1576 01ce 0F2B     		cmp	r3, #15
 1577 01d0 EEDD     		ble	.L83
 1578              	.LBE33:
 302:Src/main.c    **** 		if (curTone0 > 20 && curTone0 != lastTone0) { // play one tone using TIM14
 1579              		.loc 1 302 0 is_stmt 1
 1580 01d2 634B     		ldr	r3, .L98+64
 1581              	.LVL110:
 1582 01d4 1988     		ldrh	r1, [r3]
 1583 01d6 1429     		cmp	r1, #20
 1584 01d8 20D9     		bls	.L84
 302:Src/main.c    **** 		if (curTone0 > 20 && curTone0 != lastTone0) { // play one tone using TIM14
 1585              		.loc 1 302 0 is_stmt 0 discriminator 1
 1586 01da 644B     		ldr	r3, .L98+76
 1587 01dc 1B88     		ldrh	r3, [r3]
 1588 01de 9942     		cmp	r1, r3
 1589 01e0 1CD0     		beq	.L84
 303:Src/main.c    **** 			curPeriode0 = (uint32_t)1000000 / (uint32_t)(curTone0);
 1590              		.loc 1 303 0 is_stmt 1
 1591 01e2 4046     		mov	r0, r8
 1592 01e4 FFF7FEFF 		bl	__aeabi_uidiv
 1593              	.LVL111:
 1594 01e8 614B     		ldr	r3, .L98+80
 1595 01ea 1860     		str	r0, [r3]
 304:Src/main.c    **** 			TIM14->CNT = 0;
 1596              		.loc 1 304 0
 1597 01ec 504B     		ldr	r3, .L98+16
 1598 01ee 0022     		mov	r2, #0
ARM GAS  /tmp/cclyB5Uc.s 			page 66


 1599 01f0 5A62     		str	r2, [r3, #36]
 305:Src/main.c    **** 			TIM14->ARR = curPeriode0;
 1600              		.loc 1 305 0
 1601 01f2 D862     		str	r0, [r3, #44]
 306:Src/main.c    **** 			TIM14->CR1 = TIM14->CR1 | 1;
 1602              		.loc 1 306 0
 1603 01f4 1968     		ldr	r1, [r3]
 1604 01f6 0122     		mov	r2, #1
 1605 01f8 0A43     		orr	r2, r1
 1606 01fa 1A60     		str	r2, [r3]
 307:Src/main.c    **** 			lastTone0 = curTone0;
 1607              		.loc 1 307 0
 1608 01fc 584B     		ldr	r3, .L98+64
 1609 01fe 1A88     		ldrh	r2, [r3]
 1610 0200 5A4B     		ldr	r3, .L98+76
 1611 0202 1A80     		strh	r2, [r3]
 308:Src/main.c    **** 			noteTimeout = HAL_GetTick();
 1612              		.loc 1 308 0
 1613 0204 FFF7FEFF 		bl	HAL_GetTick
 1614              	.LVL112:
 1615 0208 5A4B     		ldr	r3, .L98+84
 1616 020a 1860     		str	r0, [r3]
 310:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, SET);
 1617              		.loc 1 310 0
 1618 020c 9020     		mov	r0, #144
 1619 020e C005     		lsl	r0, r0, #23
 1620 0210 8021     		mov	r1, #128
 1621 0212 C900     		lsl	r1, r1, #3
 1622 0214 0122     		mov	r2, #1
 1623 0216 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1624              	.LVL113:
 1625 021a 13E0     		b	.L85
 1626              	.L84:
 311:Src/main.c    **** 		} else if (curTone0 < 20 && curTone0 != lastTone0) {
 1627              		.loc 1 311 0
 1628 021c 1329     		cmp	r1, #19
 1629 021e 11D8     		bhi	.L85
 311:Src/main.c    **** 		} else if (curTone0 < 20 && curTone0 != lastTone0) {
 1630              		.loc 1 311 0 is_stmt 0 discriminator 1
 1631 0220 524B     		ldr	r3, .L98+76
 1632 0222 1B88     		ldrh	r3, [r3]
 1633 0224 9942     		cmp	r1, r3
 1634 0226 0DD0     		beq	.L85
 312:Src/main.c    **** 			TIM14->CR1 &= ~(1UL);
 1635              		.loc 1 312 0 is_stmt 1
 1636 0228 414B     		ldr	r3, .L98+16
 1637 022a 1A68     		ldr	r2, [r3]
 1638 022c 0121     		mov	r1, #1
 1639 022e 8A43     		bic	r2, r1
 1640 0230 1A60     		str	r2, [r3]
 313:Src/main.c    ****       curPeriode0 = 0;
 1641              		.loc 1 313 0
 1642 0232 0022     		mov	r2, #0
 1643 0234 4E4B     		ldr	r3, .L98+80
 1644 0236 1A60     		str	r2, [r3]
 315:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 1645              		.loc 1 315 0
ARM GAS  /tmp/cclyB5Uc.s 			page 67


 1646 0238 9020     		mov	r0, #144
 1647 023a C005     		lsl	r0, r0, #23
 1648 023c 8021     		mov	r1, #128
 1649 023e C900     		lsl	r1, r1, #3
 1650 0240 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1651              	.LVL114:
 1652              	.L85:
 318:Src/main.c    **** 		if (curTone1 > 20 && curTone1 != lastTone1) { // play other polyphonic tone ussing TIM15
 1653              		.loc 1 318 0
 1654 0244 474B     		ldr	r3, .L98+68
 1655 0246 1988     		ldrh	r1, [r3]
 1656 0248 1429     		cmp	r1, #20
 1657 024a 19D9     		bls	.L86
 318:Src/main.c    **** 		if (curTone1 > 20 && curTone1 != lastTone1) { // play other polyphonic tone ussing TIM15
 1658              		.loc 1 318 0 is_stmt 0 discriminator 1
 1659 024c 4A4B     		ldr	r3, .L98+88
 1660 024e 1B88     		ldrh	r3, [r3]
 1661 0250 9942     		cmp	r1, r3
 1662 0252 15D0     		beq	.L86
 319:Src/main.c    **** 			curPeriode1 = (uint32_t)1000000 / (uint32_t)(curTone1);
 1663              		.loc 1 319 0 is_stmt 1
 1664 0254 4046     		mov	r0, r8
 1665 0256 FFF7FEFF 		bl	__aeabi_uidiv
 1666              	.LVL115:
 1667 025a 484B     		ldr	r3, .L98+92
 1668 025c 1860     		str	r0, [r3]
 320:Src/main.c    **** 			TIM15->CNT = 0;
 1669              		.loc 1 320 0
 1670 025e 364B     		ldr	r3, .L98+24
 1671 0260 0022     		mov	r2, #0
 1672 0262 5A62     		str	r2, [r3, #36]
 321:Src/main.c    **** 			TIM15->ARR = curPeriode1;
 1673              		.loc 1 321 0
 1674 0264 D862     		str	r0, [r3, #44]
 322:Src/main.c    **** 			TIM15->CR1 = TIM15->CR1 | 1;
 1675              		.loc 1 322 0
 1676 0266 1968     		ldr	r1, [r3]
 1677 0268 0122     		mov	r2, #1
 1678 026a 0A43     		orr	r2, r1
 1679 026c 1A60     		str	r2, [r3]
 323:Src/main.c    **** 			lastTone1 = curTone1;
 1680              		.loc 1 323 0
 1681 026e 3D4B     		ldr	r3, .L98+68
 1682 0270 1A88     		ldrh	r2, [r3]
 1683 0272 414B     		ldr	r3, .L98+88
 1684 0274 1A80     		strh	r2, [r3]
 324:Src/main.c    **** 			noteTimeout = HAL_GetTick();
 1685              		.loc 1 324 0
 1686 0276 FFF7FEFF 		bl	HAL_GetTick
 1687              	.LVL116:
 1688 027a 3E4B     		ldr	r3, .L98+84
 1689 027c 1860     		str	r0, [r3]
 1690 027e 0DE0     		b	.L87
 1691              	.L86:
 325:Src/main.c    **** 		} else if (curTone1 < 20 && curTone1 != lastTone1) {
 1692              		.loc 1 325 0
 1693 0280 1329     		cmp	r1, #19
ARM GAS  /tmp/cclyB5Uc.s 			page 68


 1694 0282 0BD8     		bhi	.L87
 325:Src/main.c    **** 		} else if (curTone1 < 20 && curTone1 != lastTone1) {
 1695              		.loc 1 325 0 is_stmt 0 discriminator 1
 1696 0284 3C4B     		ldr	r3, .L98+88
 1697 0286 1B88     		ldrh	r3, [r3]
 1698 0288 9942     		cmp	r1, r3
 1699 028a 07D0     		beq	.L87
 326:Src/main.c    **** 			TIM15->CR1 &= ~(1UL);
 1700              		.loc 1 326 0 is_stmt 1
 1701 028c 2A4B     		ldr	r3, .L98+24
 1702 028e 1A68     		ldr	r2, [r3]
 1703 0290 0121     		mov	r1, #1
 1704 0292 8A43     		bic	r2, r1
 1705 0294 1A60     		str	r2, [r3]
 327:Src/main.c    ****       curPeriode1 = 0;
 1706              		.loc 1 327 0
 1707 0296 0022     		mov	r2, #0
 1708 0298 384B     		ldr	r3, .L98+92
 1709 029a 1A60     		str	r2, [r3]
 1710              	.L87:
 330:Src/main.c    **** 		if ((HAL_GetTick() - noteTimeout) > 1000) {
 1711              		.loc 1 330 0
 1712 029c FFF7FEFF 		bl	HAL_GetTick
 1713              	.LVL117:
 1714 02a0 344B     		ldr	r3, .L98+84
 1715 02a2 1B68     		ldr	r3, [r3]
 1716 02a4 C01A     		sub	r0, r0, r3
 1717 02a6 FA23     		mov	r3, #250
 1718 02a8 9B00     		lsl	r3, r3, #2
 1719 02aa 9842     		cmp	r0, r3
 1720 02ac 18D9     		bls	.L88
 331:Src/main.c    **** 			TIM14->CR1 &= ~(1UL);
 1721              		.loc 1 331 0
 1722 02ae 204B     		ldr	r3, .L98+16
 1723 02b0 1968     		ldr	r1, [r3]
 1724 02b2 0122     		mov	r2, #1
 1725 02b4 9143     		bic	r1, r2
 1726 02b6 1960     		str	r1, [r3]
 332:Src/main.c    **** 			TIM15->CR1 &= ~(1UL);
 1727              		.loc 1 332 0
 1728 02b8 1F4B     		ldr	r3, .L98+24
 1729 02ba 1968     		ldr	r1, [r3]
 1730 02bc 9143     		bic	r1, r2
 1731 02be 1960     		str	r1, [r3]
 1732              	.LVL118:
 1733              	.LBB34:
 333:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 1734              		.loc 1 333 0
 1735 02c0 0023     		mov	r3, #0
 334:Src/main.c    **** 				freqs[i] = 0;
 1736              		.loc 1 334 0
 1737 02c2 2948     		ldr	r0, .L98+72
 1738 02c4 0021     		mov	r1, #0
 333:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 1739              		.loc 1 333 0
 1740 02c6 02E0     		b	.L89
 1741              	.LVL119:
ARM GAS  /tmp/cclyB5Uc.s 			page 69


 1742              	.L90:
 334:Src/main.c    **** 				freqs[i] = 0;
 1743              		.loc 1 334 0 discriminator 2
 1744 02c8 5A00     		lsl	r2, r3, #1
 1745 02ca 1152     		strh	r1, [r2, r0]
 333:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 1746              		.loc 1 333 0 discriminator 2
 1747 02cc 0133     		add	r3, r3, #1
 1748              	.LVL120:
 1749              	.L89:
 333:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 1750              		.loc 1 333 0 is_stmt 0 discriminator 1
 1751 02ce 0F2B     		cmp	r3, #15
 1752 02d0 FADD     		ble	.L90
 1753              	.LBE34:
 337:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 1754              		.loc 1 337 0 is_stmt 1
 1755 02d2 9020     		mov	r0, #144
 1756 02d4 C005     		lsl	r0, r0, #23
 1757 02d6 8021     		mov	r1, #128
 1758 02d8 C900     		lsl	r1, r1, #3
 1759 02da 0022     		mov	r2, #0
 1760 02dc FFF7FEFF 		bl	HAL_GPIO_WritePin
 1761              	.LVL121:
 1762              	.L88:
 343:Src/main.c    **** 		if( FUNC_SUCCESS == midiGetFromUsbRx(0, &uart_tx_dat)){
 1763              		.loc 1 343 0
 1764 02e0 0020     		mov	r0, #0
 1765 02e2 2749     		ldr	r1, .L98+96
 1766 02e4 FFF7FEFF 		bl	midiGetFromUsbRx
 1767              	.LVL122:
 1768 02e8 0128     		cmp	r0, #1
 1769 02ea 00D0     		beq	.LCB1503
 1770 02ec 29E7     		b	.L94	@long jump
 1771              	.LCB1503:
 344:Src/main.c    **** 			if (uart_tx_dat >> 7 == 1) {
 1772              		.loc 1 344 0
 1773 02ee 244B     		ldr	r3, .L98+96
 1774 02f0 1B78     		ldrb	r3, [r3]
 1775 02f2 DA09     		lsr	r2, r3, #7
 1776 02f4 012A     		cmp	r2, #1
 1777 02f6 08D1     		bne	.L91
 345:Src/main.c    **** 				midiBuffer[0] = uart_tx_dat;
 1778              		.loc 1 345 0
 1779 02f8 224A     		ldr	r2, .L98+100
 1780 02fa 1370     		strb	r3, [r2]
 346:Src/main.c    **** 				midiBuffer[1] = 0;
 1781              		.loc 1 346 0
 1782 02fc 0023     		mov	r3, #0
 1783 02fe 5370     		strb	r3, [r2, #1]
 347:Src/main.c    **** 				midiBuffer[2] = 0;
 1784              		.loc 1 347 0
 1785 0300 9370     		strb	r3, [r2, #2]
 348:Src/main.c    **** 				midiState = 1;
 1786              		.loc 1 348 0
 1787 0302 0122     		mov	r2, #1
 1788 0304 204B     		ldr	r3, .L98+104
ARM GAS  /tmp/cclyB5Uc.s 			page 70


 1789 0306 1A70     		strb	r2, [r3]
 1790 0308 1BE7     		b	.L94
 1791              	.L91:
 349:Src/main.c    **** 			} else if (midiState == 1) {
 1792              		.loc 1 349 0
 1793 030a 1F4A     		ldr	r2, .L98+104
 1794 030c 1278     		ldrb	r2, [r2]
 1795 030e 012A     		cmp	r2, #1
 1796 0310 3CD1     		bne	.L92
 350:Src/main.c    **** 				midiBuffer[1] = uart_tx_dat;
 1797              		.loc 1 350 0
 1798 0312 1C4A     		ldr	r2, .L98+100
 1799 0314 5370     		strb	r3, [r2, #1]
 351:Src/main.c    **** 				midiState = 2;
 1800              		.loc 1 351 0
 1801 0316 0222     		mov	r2, #2
 1802 0318 1B4B     		ldr	r3, .L98+104
 1803 031a 1A70     		strb	r2, [r3]
 1804 031c 11E7     		b	.L94
 1805              	.L99:
 1806 031e C046     		.align	3
 1807              	.L98:
 1808 0320 00000000 		.word	0
 1809 0324 00002840 		.word	1076363264
 1810 0328 00000000 		.word	hdac
 1811 032c 00000000 		.word	htim14
 1812 0330 00200040 		.word	1073750016
 1813 0334 00000000 		.word	htim15
 1814 0338 00400140 		.word	1073823744
 1815 033c 00000000 		.word	hadc
 1816 0340 00000000 		.word	adcBuffer
 1817 0344 00000000 		.word	htim1
 1818 0348 00000000 		.word	htim2
 1819 034c 00000000 		.word	hUsbDeviceFS
 1820 0350 00000000 		.word	htim17
 1821 0354 00000000 		.word	.LANCHOR5
 1822 0358 00000000 		.word	.LANCHOR2
 1823 035c 40420F00 		.word	1000000
 1824 0360 00000000 		.word	.LANCHOR6
 1825 0364 00000000 		.word	.LANCHOR7
 1826 0368 00000000 		.word	.LANCHOR8
 1827 036c 00000000 		.word	.LANCHOR9
 1828 0370 00000000 		.word	.LANCHOR3
 1829 0374 00000000 		.word	.LANCHOR10
 1830 0378 00000000 		.word	.LANCHOR11
 1831 037c 00000000 		.word	.LANCHOR4
 1832 0380 00000000 		.word	uart_tx_dat
 1833 0384 00000000 		.word	midiBuffer
 1834 0388 00000000 		.word	.LANCHOR12
 1835              	.L92:
 352:Src/main.c    **** 			} else if (midiState == 2) {
 1836              		.loc 1 352 0
 1837 038c 022A     		cmp	r2, #2
 1838 038e 00D0     		beq	.LCB1567
 1839 0390 D7E6     		b	.L94	@long jump
 1840              	.LCB1567:
 353:Src/main.c    **** 				midiBuffer[2] = uart_tx_dat;
ARM GAS  /tmp/cclyB5Uc.s 			page 71


 1841              		.loc 1 353 0
 1842 0392 274A     		ldr	r2, .L100+16
 1843 0394 9370     		strb	r3, [r2, #2]
 354:Src/main.c    **** 				midiState = 3;
 1844              		.loc 1 354 0
 1845 0396 0321     		mov	r1, #3
 1846 0398 264B     		ldr	r3, .L100+20
 1847 039a 1970     		strb	r1, [r3]
 356:Src/main.c    **** 				if ((midiBuffer[0] & 0xF0) == 0x90) { // Note on, 2 data bytes
 1848              		.loc 1 356 0
 1849 039c 1378     		ldrb	r3, [r2]
 1850 039e 0F22     		mov	r2, #15
 1851 03a0 9343     		bic	r3, r2
 1852 03a2 902B     		cmp	r3, #144
 1853 03a4 1CD1     		bne	.L93
 1854              	.LBB35:
 357:Src/main.c    **** 					char key = midiBuffer[1];
 1855              		.loc 1 357 0
 1856 03a6 224E     		ldr	r6, .L100+16
 1857 03a8 7078     		ldrb	r0, [r6, #1]
 1858              	.LVL123:
 360:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 1859              		.loc 1 360 0
 1860 03aa 4538     		sub	r0, r0, #69
 1861 03ac FFF7FEFF 		bl	__aeabi_i2d
 1862              	.LVL124:
 1863 03b0 009A     		ldr	r2, [sp]
 1864 03b2 019B     		ldr	r3, [sp, #4]
 1865 03b4 FFF7FEFF 		bl	__aeabi_ddiv
 1866              	.LVL125:
 1867 03b8 021C     		mov	r2, r0
 1868 03ba 0B1C     		mov	r3, r1
 1869 03bc 1949     		ldr	r1, .L100+4
 1870 03be 1848     		ldr	r0, .L100
 1871 03c0 FFF7FEFF 		bl	pow
 1872              	.LVL126:
 1873 03c4 184A     		ldr	r2, .L100+8
 1874 03c6 194B     		ldr	r3, .L100+12
 1875 03c8 FFF7FEFF 		bl	__aeabi_dmul
 1876              	.LVL127:
 1877 03cc FFF7FEFF 		bl	__aeabi_d2uiz
 1878              	.LVL128:
 361:Src/main.c    **** 					curChannel = midiBuffer[0] & 0xF;
 1879              		.loc 1 361 0
 1880 03d0 3278     		ldrb	r2, [r6]
 1881 03d2 0F23     		mov	r3, #15
 1882 03d4 1340     		and	r3, r2
 1883 03d6 184A     		ldr	r2, .L100+24
 1884 03d8 1380     		strh	r3, [r2]
 362:Src/main.c    **** 					freqs[curChannel] = freq;
 1885              		.loc 1 362 0
 1886 03da 5B00     		lsl	r3, r3, #1
 1887 03dc 174A     		ldr	r2, .L100+28
 1888 03de D052     		strh	r0, [r2, r3]
 1889              	.LVL129:
 1890              	.L93:
 1891              	.LBE35:
ARM GAS  /tmp/cclyB5Uc.s 			page 72


 365:Src/main.c    **** 				} if ((midiBuffer[0] &0xF0) == 0x80) { // Note off, 2 data bytes
 1892              		.loc 1 365 0
 1893 03e0 134B     		ldr	r3, .L100+16
 1894 03e2 1B78     		ldrb	r3, [r3]
 1895 03e4 0F22     		mov	r2, #15
 1896 03e6 9343     		bic	r3, r2
 1897 03e8 802B     		cmp	r3, #128
 1898 03ea 00D0     		beq	.LCB1626
 1899 03ec A9E6     		b	.L94	@long jump
 1900              	.LCB1626:
 1901              	.LBB36:
 366:Src/main.c    **** 					char key = midiBuffer[1];
 1902              		.loc 1 366 0
 1903 03ee 104E     		ldr	r6, .L100+16
 1904 03f0 7078     		ldrb	r0, [r6, #1]
 1905              	.LVL130:
 369:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 1906              		.loc 1 369 0
 1907 03f2 4538     		sub	r0, r0, #69
 1908 03f4 FFF7FEFF 		bl	__aeabi_i2d
 1909              	.LVL131:
 1910 03f8 009A     		ldr	r2, [sp]
 1911 03fa 019B     		ldr	r3, [sp, #4]
 1912 03fc FFF7FEFF 		bl	__aeabi_ddiv
 1913              	.LVL132:
 1914 0400 021C     		mov	r2, r0
 1915 0402 0B1C     		mov	r3, r1
 1916 0404 0749     		ldr	r1, .L100+4
 1917 0406 0648     		ldr	r0, .L100
 1918 0408 FFF7FEFF 		bl	pow
 1919              	.LVL133:
 372:Src/main.c    **** 					freqs[midiBuffer[0] & 0xF] = 0;
 1920              		.loc 1 372 0
 1921 040c 3278     		ldrb	r2, [r6]
 1922 040e 0F23     		mov	r3, #15
 1923 0410 1A40     		and	r2, r3
 1924 0412 5200     		lsl	r2, r2, #1
 1925 0414 0021     		mov	r1, #0
 1926 0416 094B     		ldr	r3, .L100+28
 1927 0418 D152     		strh	r1, [r2, r3]
 1928 041a 92E6     		b	.L94
 1929              	.L101:
 1930 041c C046C046 		.align	3
 1931              	.L100:
 1932 0420 00000000 		.word	0
 1933 0424 00000040 		.word	1073741824
 1934 0428 00000000 		.word	0
 1935 042c 00807B40 		.word	1081835520
 1936 0430 00000000 		.word	midiBuffer
 1937 0434 00000000 		.word	.LANCHOR12
 1938 0438 00000000 		.word	.LANCHOR13
 1939 043c 00000000 		.word	.LANCHOR8
 1940              	.LBE36:
 1941              		.cfi_endproc
 1942              	.LFE37:
 1944              		.global	freqs
 1945              		.global	noteTimeout
ARM GAS  /tmp/cclyB5Uc.s 			page 73


 1946              		.global	lastTone1
 1947              		.global	lastTone0
 1948              		.global	curChannel
 1949              		.global	curTone1
 1950              		.global	curTone0
 1951              		.global	midiState
 1952              		.comm	midiBuffer,4,4
 1953              		.global	curPeriode1
 1954              		.global	curPeriode0
 1955              		.global	Vmax
 1956              		.global	Vset
 1957              		.global	Iout
 1958              		.global	Vout
 1959              		.comm	uart_tx_dat,1,1
 1960              		.comm	adcBuffer,6,4
 1961              		.comm	hdma_adc,68,4
 1962              		.comm	hadc,76,4
 1963              		.comm	hdac,20,4
 1964              		.comm	htim1,64,4
 1965              		.comm	htim2,64,4
 1966              		.comm	htim17,64,4
 1967              		.comm	htim15,64,4
 1968              		.comm	htim14,64,4
 1969              		.section	.bss.curTone1,"aw",%nobits
 1970              		.align	1
 1971              		.set	.LANCHOR7,. + 0
 1974              	curTone1:
 1975 0000 0000     		.space	2
 1976              		.section	.bss.lastTone0,"aw",%nobits
 1977              		.align	1
 1978              		.set	.LANCHOR9,. + 0
 1981              	lastTone0:
 1982 0000 0000     		.space	2
 1983              		.section	.bss.lastTone1,"aw",%nobits
 1984              		.align	1
 1985              		.set	.LANCHOR11,. + 0
 1988              	lastTone1:
 1989 0000 0000     		.space	2
 1990              		.section	.bss.curTone0,"aw",%nobits
 1991              		.align	1
 1992              		.set	.LANCHOR6,. + 0
 1995              	curTone0:
 1996 0000 0000     		.space	2
 1997              		.section	.bss.Vout,"aw",%nobits
 1998              		.align	2
 1999              		.set	.LANCHOR1,. + 0
 2002              	Vout:
 2003 0000 00000000 		.space	4
 2004              		.section	.bss.curPeriode0,"aw",%nobits
 2005              		.align	2
 2006              		.set	.LANCHOR3,. + 0
 2009              	curPeriode0:
 2010 0000 00000000 		.space	4
 2011              		.section	.bss.curPeriode1,"aw",%nobits
 2012              		.align	2
 2013              		.set	.LANCHOR4,. + 0
 2016              	curPeriode1:
ARM GAS  /tmp/cclyB5Uc.s 			page 74


 2017 0000 00000000 		.space	4
 2018              		.section	.bss.noteTimeout,"aw",%nobits
 2019              		.align	2
 2020              		.set	.LANCHOR10,. + 0
 2023              	noteTimeout:
 2024 0000 00000000 		.space	4
 2025              		.section	.bss.freqs,"aw",%nobits
 2026              		.align	2
 2027              		.set	.LANCHOR8,. + 0
 2030              	freqs:
 2031 0000 00000000 		.space	32
 2031      00000000 
 2031      00000000 
 2031      00000000 
 2031      00000000 
 2032              		.section	.rodata.str1.4,"aMS",%progbits,1
 2033              		.align	2
 2034              	.LC9:
 2035 0000 5372632F 		.ascii	"Src/main.c\000"
 2035      6D61696E 
 2035      2E6300
 2036 000b 00       		.section	.data.Vmax,"aw",%progbits
 2037              		.align	2
 2038              		.set	.LANCHOR5,. + 0
 2041              	Vmax:
 2042 0000 20CB0000 		.word	52000
 2043              		.section	.bss.curChannel,"aw",%nobits
 2044              		.align	1
 2045              		.set	.LANCHOR13,. + 0
 2048              	curChannel:
 2049 0000 0000     		.space	2
 2050              		.section	.bss.midiState,"aw",%nobits
 2051              		.set	.LANCHOR12,. + 0
 2054              	midiState:
 2055 0000 00       		.space	1
 2056              		.section	.bss.Iout,"aw",%nobits
 2057              		.align	1
 2058              		.set	.LANCHOR0,. + 0
 2061              	Iout:
 2062 0000 0000     		.space	2
 2063              		.section	.bss.Vset,"aw",%nobits
 2064              		.align	2
 2065              		.set	.LANCHOR2,. + 0
 2068              	Vset:
 2069 0000 00000000 		.space	4
 2070              		.text
 2071              	.Letext0:
 2072              		.file 4 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h"
 2073              		.file 5 "/home/niklas/Downloads/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/machine/_defaul
 2074              		.file 6 "/home/niklas/Downloads/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/stdint.h"
 2075              		.file 7 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f0xx.h"
 2076              		.file 8 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_def.h"
 2077              		.file 9 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rcc.h"
 2078              		.file 10 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rcc_ex.h"
 2079              		.file 11 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_gpio.h"
 2080              		.file 12 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_dma.h"
 2081              		.file 13 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_adc.h"
ARM GAS  /tmp/cclyB5Uc.s 			page 75


 2082              		.file 14 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_dac.h"
 2083              		.file 15 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_tim.h"
 2084              		.file 16 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_tim_ex.h"
 2085              		.file 17 "Middlewares/ST/STM32_USB_Device_Library/Core/Inc/usbd_def.h"
 2086              		.file 18 "Inc/curelib_inc/curemisc.h"
 2087              		.file 19 "Inc/usb_device.h"
 2088              		.file 20 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_cortex.h"
 2089              		.file 21 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal.h"
 2090              		.file 22 "Inc/usbd_midi_if.h"
 2091              		.file 23 "/home/niklas/Downloads/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/math.h"
ARM GAS  /tmp/cclyB5Uc.s 			page 76


DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/cclyB5Uc.s:18     .text.MX_GPIO_Init:00000000 $t
     /tmp/cclyB5Uc.s:22     .text.MX_GPIO_Init:00000000 MX_GPIO_Init
     /tmp/cclyB5Uc.s:105    .text.MX_GPIO_Init:00000068 $d
     /tmp/cclyB5Uc.s:110    .text.MX_DMA_Init:00000000 $t
     /tmp/cclyB5Uc.s:114    .text.MX_DMA_Init:00000000 MX_DMA_Init
     /tmp/cclyB5Uc.s:154    .text.MX_DMA_Init:0000002c $d
     /tmp/cclyB5Uc.s:159    .text.USER_TIM2_Init:00000000 $t
     /tmp/cclyB5Uc.s:163    .text.USER_TIM2_Init:00000000 USER_TIM2_Init
     /tmp/cclyB5Uc.s:252    .text.USER_TIM2_Init:0000006c $d
                            *COM*:00000040 htim2
     /tmp/cclyB5Uc.s:262    .text.htim17_update:00000000 $t
     /tmp/cclyB5Uc.s:267    .text.htim17_update:00000000 htim17_update
     /tmp/cclyB5Uc.s:348    .text.htim17_update:00000060 $d
                            *COM*:00000006 adcBuffer
     /tmp/cclyB5Uc.s:361    .text.dfu_otter_bootloader:00000000 $t
     /tmp/cclyB5Uc.s:366    .text.dfu_otter_bootloader:00000000 dfu_otter_bootloader
     /tmp/cclyB5Uc.s:412    .text.dfu_otter_bootloader:00000018 $d
     /tmp/cclyB5Uc.s:425    .text.HAL_TIM_PeriodElapsedCallback:00000000 $t
     /tmp/cclyB5Uc.s:430    .text.HAL_TIM_PeriodElapsedCallback:00000000 HAL_TIM_PeriodElapsedCallback
     /tmp/cclyB5Uc.s:520    .text.HAL_TIM_PeriodElapsedCallback:00000074 $d
     /tmp/cclyB5Uc.s:529    .text._Error_Handler:00000000 $t
     /tmp/cclyB5Uc.s:534    .text._Error_Handler:00000000 _Error_Handler
     /tmp/cclyB5Uc.s:545    .text.MX_DAC_Init:00000000 $t
     /tmp/cclyB5Uc.s:549    .text.MX_DAC_Init:00000000 MX_DAC_Init
     /tmp/cclyB5Uc.s:603    .text.MX_DAC_Init:0000003c $d
                            *COM*:00000014 hdac
     /tmp/cclyB5Uc.s:611    .text.MX_TIM14_Init:00000000 $t
     /tmp/cclyB5Uc.s:615    .text.MX_TIM14_Init:00000000 MX_TIM14_Init
     /tmp/cclyB5Uc.s:663    .text.MX_TIM14_Init:00000034 $d
                            *COM*:00000040 htim14
     /tmp/cclyB5Uc.s:671    .text.MX_TIM15_Init:00000000 $t
     /tmp/cclyB5Uc.s:675    .text.MX_TIM15_Init:00000000 MX_TIM15_Init
     /tmp/cclyB5Uc.s:723    .text.MX_TIM15_Init:00000034 $d
                            *COM*:00000040 htim15
     /tmp/cclyB5Uc.s:731    .text.MX_ADC_Init:00000000 $t
     /tmp/cclyB5Uc.s:735    .text.MX_ADC_Init:00000000 MX_ADC_Init
     /tmp/cclyB5Uc.s:871    .text.MX_ADC_Init:000000b0 $d
                            *COM*:0000004c hadc
     /tmp/cclyB5Uc.s:879    .text.USER_TIM1_Init:00000000 $t
     /tmp/cclyB5Uc.s:883    .text.USER_TIM1_Init:00000000 USER_TIM1_Init
     /tmp/cclyB5Uc.s:1030   .text.USER_TIM1_Init:000000bc $d
                            *COM*:00000040 htim1
     /tmp/cclyB5Uc.s:1042   .text.MX_TIM17_Init:00000000 $t
     /tmp/cclyB5Uc.s:1046   .text.MX_TIM17_Init:00000000 MX_TIM17_Init
     /tmp/cclyB5Uc.s:1095   .text.MX_TIM17_Init:00000034 $d
                            *COM*:00000040 htim17
     /tmp/cclyB5Uc.s:1103   .text.SystemClock_Config:00000000 $t
     /tmp/cclyB5Uc.s:1108   .text.SystemClock_Config:00000000 SystemClock_Config
     /tmp/cclyB5Uc.s:1218   .text.SystemClock_Config:00000094 $d
     /tmp/cclyB5Uc.s:1227   .text.main:00000000 $t
     /tmp/cclyB5Uc.s:1232   .text.main:00000000 main
     /tmp/cclyB5Uc.s:1808   .text.main:00000320 $d
                            *COM*:00000001 uart_tx_dat
                            *COM*:00000004 midiBuffer
     /tmp/cclyB5Uc.s:1837   .text.main:0000038c $t
ARM GAS  /tmp/cclyB5Uc.s 			page 77


     /tmp/cclyB5Uc.s:1932   .text.main:00000420 $d
     /tmp/cclyB5Uc.s:2030   .bss.freqs:00000000 freqs
     /tmp/cclyB5Uc.s:2023   .bss.noteTimeout:00000000 noteTimeout
     /tmp/cclyB5Uc.s:1988   .bss.lastTone1:00000000 lastTone1
     /tmp/cclyB5Uc.s:1981   .bss.lastTone0:00000000 lastTone0
     /tmp/cclyB5Uc.s:2048   .bss.curChannel:00000000 curChannel
     /tmp/cclyB5Uc.s:1974   .bss.curTone1:00000000 curTone1
     /tmp/cclyB5Uc.s:1995   .bss.curTone0:00000000 curTone0
     /tmp/cclyB5Uc.s:2054   .bss.midiState:00000000 midiState
     /tmp/cclyB5Uc.s:2016   .bss.curPeriode1:00000000 curPeriode1
     /tmp/cclyB5Uc.s:2009   .bss.curPeriode0:00000000 curPeriode0
     /tmp/cclyB5Uc.s:2041   .data.Vmax:00000000 Vmax
     /tmp/cclyB5Uc.s:2068   .bss.Vset:00000000 Vset
     /tmp/cclyB5Uc.s:2061   .bss.Iout:00000000 Iout
     /tmp/cclyB5Uc.s:2002   .bss.Vout:00000000 Vout
                            *COM*:00000044 hdma_adc
     /tmp/cclyB5Uc.s:1970   .bss.curTone1:00000000 $d
     /tmp/cclyB5Uc.s:1977   .bss.lastTone0:00000000 $d
     /tmp/cclyB5Uc.s:1984   .bss.lastTone1:00000000 $d
     /tmp/cclyB5Uc.s:1991   .bss.curTone0:00000000 $d
     /tmp/cclyB5Uc.s:1998   .bss.Vout:00000000 $d
     /tmp/cclyB5Uc.s:2005   .bss.curPeriode0:00000000 $d
     /tmp/cclyB5Uc.s:2012   .bss.curPeriode1:00000000 $d
     /tmp/cclyB5Uc.s:2019   .bss.noteTimeout:00000000 $d
     /tmp/cclyB5Uc.s:2026   .bss.freqs:00000000 $d
     /tmp/cclyB5Uc.s:2033   .rodata.str1.4:00000000 $d
     /tmp/cclyB5Uc.s:2037   .data.Vmax:00000000 $d
     /tmp/cclyB5Uc.s:2044   .bss.curChannel:00000000 $d
     /tmp/cclyB5Uc.s:2055   .bss.midiState:00000000 $d
     /tmp/cclyB5Uc.s:2057   .bss.Iout:00000000 $d
     /tmp/cclyB5Uc.s:2064   .bss.Vset:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
HAL_GPIO_WritePin
HAL_GPIO_Init
HAL_NVIC_SetPriority
HAL_NVIC_EnableIRQ
HAL_TIM_Base_Init
HAL_TIMEx_MasterConfigSynchronization
HAL_TIM_PWM_ConfigChannel
HAL_TIM_OnePulse_Init
HAL_TIM_MspPostInit
__aeabi_i2f
__aeabi_fmul
__aeabi_f2uiz
__aeabi_idiv
__aeabi_uidiv
HAL_DAC_Init
HAL_DAC_ConfigChannel
HAL_ADC_Init
HAL_ADC_ConfigChannel
HAL_TIM_PWM_Init
HAL_TIMEx_ConfigBreakDeadTime
HAL_RCC_OscConfig
HAL_RCC_ClockConfig
HAL_RCCEx_PeriphCLKConfig
ARM GAS  /tmp/cclyB5Uc.s 			page 78


HAL_RCC_GetHCLKFreq
HAL_SYSTICK_Config
HAL_SYSTICK_CLKSourceConfig
__aeabi_i2d
__aeabi_ddiv
__aeabi_dmul
__aeabi_d2uiz
HAL_Init
HAL_DAC_Start
HAL_DAC_SetValue
HAL_TIM_Base_Start_IT
HAL_ADC_Start_DMA
HAL_TIM_PWM_Start_IT
HAL_TIM_Base_Start
HAL_TIM_OnePulse_Start
MX_USB_MIDI_INIT
midiInit
HAL_Delay
HAL_GPIO_ReadPin
HAL_GetTick
midiGetFromUsbRx
hUsbDeviceFS
pow
